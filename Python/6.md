# Python Functions & Recursion: Complete Guide for Biomedical AI

## üìã Prerequisites Check
- **Required**: Basic Python syntax (variables, data types, loops, conditionals)
- **Helpful**: Understanding of mathematical operations and basic algebra
- **Not Required**: Prior programming experience beyond basics

---

## üéØ Key Takeaways

1. **Functions eliminate code redundancy** - Write once, use anywhere
2. **Recursion = Functions calling themselves** - Powerful for specific problems
3. **Every function needs**: Definition, parameters (optional), and optionally returns values
4. **Best Practice**: If you write the same code 2-3 times ‚Üí make it a function
5. **Critical for ML/AI**: Functions are fundamental to building modular, production-grade systems

---

## üß† Intuitive Overview: Why Functions Matter

### The Problem Functions Solve

Imagine you're analyzing protein sequences and need to calculate similarity scores repeatedly:

```python
# Bad approach - redundant code
sequence1_a = "ATCG"
sequence1_b = "ATCC"
similarity1 = calculate_similarity_logic_here  # 10 lines of code

# 100 lines later...
sequence2_a = "GCTA"
sequence2_b = "GCAA"
similarity2 = same_similarity_logic_again  # Same 10 lines repeated!
```

**This is redundant code** - a sign of poor programming. Functions solve this:

```python
def calculate_similarity(seq_a, seq_b):
    # Logic written once
    return similarity_score

# Use anywhere
similarity1 = calculate_similarity("ATCG", "ATCC")
similarity2 = calculate_similarity("GCTA", "GCAA")
```

### Mental Model: Functions as Black Boxes

Think of a function like a laboratory instrument:
- **Input** (parameters): Raw samples you feed in
- **Process**: Internal mechanism (your code)
- **Output** (return value): Results you get back

---

## üìö Deep Dive: Functions

### 1. Function Anatomy

```python
def function_name(parameter1, parameter2):  # Function definition
    """Optional docstring explaining what this does"""
    # Function body - the work happens here
    result = parameter1 + parameter2
    return result  # Optional: send back a value
```

**Key Components**:
- `def`: Keyword to **define** a function
- `function_name`: Choose descriptive names (like `calculate_protein_mass`, not `func1`)
- `parameters`: Variables that receive input values
- `return`: Sends a value back to the caller (optional)

### 2. Creating Your First Function

```python
# Simple example: Calculate sum of two numbers
def calculate_sum(a, b):
    sum_value = a + b
    return sum_value

# Using the function (calling it)
result = calculate_sum(5, 10)
print(result)  # Output: 15
```

**What's happening**:
1. We **define** the function once
2. When we **call** `calculate_sum(5, 10)`:
   - `a` gets value `5`
   - `b` gets value `10`
   - Function calculates and returns `15`

### 3. Parameters vs Arguments

**Terminology clarity** (important for communication):

```python
def greet(name, greeting):  # 'name' and 'greeting' are PARAMETERS
    print(f"{greeting}, {name}!")

greet("Alice", "Hello")  # "Alice" and "Hello" are ARGUMENTS
```

- **Parameters**: Variables in the function definition (placeholders)
- **Arguments**: Actual values you pass when calling (real data)

### 4. Functions Without Parameters

```python
def print_hello():  # No parameters needed
    print("Hello, World!")

print_hello()  # Just call it - no arguments
```

**Use case in biomedical AI**: Configuration functions, logging, initialization

### 5. Functions Without Return Values

```python
def log_experiment(experiment_id):
    print(f"Running experiment: {experiment_id}")
    # No return statement - returns None implicitly

result = log_experiment("EXP_001")
print(result)  # Output: None
```

**Important**: Functions without `return` automatically return `None`

### 6. Default Parameters (Optional Arguments)

```python
def calculate_product(a=1, b=1):  # Default values
    return a * b

print(calculate_product())       # Uses defaults: 1 * 1 = 1
print(calculate_product(5))      # a=5, b=1 (default) = 5
print(calculate_product(5, 3))   # a=5, b=3 = 15
```

**Rule**: Default parameters MUST come after non-default ones

```python
# ‚ùå WRONG
def bad_function(a=1, b):  # Error!
    return a + b

# ‚úÖ CORRECT
def good_function(b, a=1):  # Non-default first
    return a + b
```

### 7. Built-in vs User-Defined Functions

**Built-in Functions** (already in Python):
```python
print("Hello")           # We've used this since day 1!
len([1, 2, 3])          # Returns 3
type(42)                # Returns <class 'int'>
range(1, 10)            # Generates sequence
```

**User-Defined Functions** (you create):
```python
def my_custom_function():
    # Your logic here
    pass
```

---

## üß¨ Biomedical AI Applications

### Example 1: Drug Concentration Calculator

```python
def calculate_concentration(mass_mg, volume_ml):
    """
    Calculate drug concentration in mg/mL.
    
    Args:
        mass_mg: Drug mass in milligrams
        volume_ml: Solution volume in milliliters
    
    Returns:
        Concentration in mg/mL
    """
    if volume_ml == 0:
        return None  # Avoid division by zero
    
    concentration = mass_mg / volume_ml
    return concentration

# Use in drug discovery pipeline
conc1 = calculate_concentration(500, 100)  # 5.0 mg/mL
conc2 = calculate_concentration(250, 50)   # 5.0 mg/mL
```

### Example 2: Sequence Length Validator

```python
def validate_sequence_length(sequence, min_length=50):
    """Check if DNA/protein sequence meets minimum length."""
    length = len(sequence)
    
    if length >= min_length:
        print(f"‚úì Valid: {length} bp/aa")
        return True
    else:
        print(f"‚úó Too short: {length} < {min_length}")
        return False

# Use in preprocessing pipeline
dna = "ATCGATCGATCG..."
if validate_sequence_length(dna):
    # Proceed with analysis
    pass
```

---

## üîÑ Recursion: Functions Calling Themselves

### What is Recursion?

**Simple definition**: A function that calls itself to solve smaller versions of the same problem.

**Mental Model**: Think of Russian nesting dolls (matryoshka)
- Each doll contains a smaller version of itself
- Eventually, you reach the smallest doll (base case)
- Then you work your way back up

### Why Recursion Matters (Especially for Beginners)

‚ö†Ô∏è **Important Reality Check**:
- Recursion is **conceptually challenging** for beginners
- It's **okay** if you don't understand it immediately
- Many experienced programmers struggled with it initially
- You might need to review this section 2-3 times

**When to use recursion**:
- Tree/graph traversal (common in biological networks)
- Divide-and-conquer algorithms
- Mathematical sequences
- When iterative solutions become complex

**When NOT to use**:
- Simple loops work fine
- Performance is critical (recursion has overhead)
- Most beginner-level problems

### Basic Recursion Example

```python
def show(n):
    if n == 0:  # BASE CASE - stopping condition
        return
    
    print(n)          # Do something
    show(n - 1)       # RECURSIVE CALL - call yourself with smaller input

show(5)
# Output:
# 5
# 4
# 3
# 2
# 1
```

**What's happening**:
1. `show(5)` prints 5, calls `show(4)`
2. `show(4)` prints 4, calls `show(3)`
3. `show(3)` prints 3, calls `show(2)`
4. `show(2)` prints 2, calls `show(1)`
5. `show(1)` prints 1, calls `show(0)`
6. `show(0)` hits base case ‚Üí returns (stops recursion)

### The Call Stack (How Recursion Works Internally)

Think of the **call stack** as a stack of plates:

```
show(5) called:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   show(5)   ‚îÇ ‚Üê Top of stack
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Then show(4) called:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   show(4)   ‚îÇ ‚Üê New call on top
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   show(5)   ‚îÇ ‚Üê Waiting...
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Then show(3) called:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   show(3)   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   show(4)   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   show(5)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

...continues until show(0)...

When show(0) returns:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   show(1)   ‚îÇ ‚Üê Back to show(1), it finishes
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   show(2)   ‚îÇ ‚Üê Then show(2) finishes
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   show(3)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Memory implication**: Each recursive call takes memory. Too many calls ‚Üí Stack Overflow!

### Classic Recursion: Factorial

**Mathematical definition**:
- 5! = 5 √ó 4 √ó 3 √ó 2 √ó 1 = 120
- **Recursive insight**: n! = n √ó (n-1)!
- **Base case**: 0! = 1, 1! = 1

```python
def factorial(n):
    # Base case - stopping condition
    if n <= 1:
        return 1
    
    # Recursive case - call yourself with smaller problem
    return n * factorial(n - 1)

print(factorial(5))  # 120
print(factorial(6))  # 720
```

**Step-by-step for factorial(4)**:

```python
factorial(4)
= 4 * factorial(3)
= 4 * (3 * factorial(2))
= 4 * (3 * (2 * factorial(1)))
= 4 * (3 * (2 * 1))          # Base case hit!
= 4 * (3 * 2)
= 4 * 6
= 24
```

### Recursion: Sum of Natural Numbers

**Problem**: Calculate 1 + 2 + 3 + ... + n

```python
def calculate_sum(n):
    # Base case
    if n == 0:
        return 0
    
    # Recursive case: current number + sum of all smaller numbers
    return n + calculate_sum(n - 1)

print(calculate_sum(5))   # 1+2+3+4+5 = 15
print(calculate_sum(10))  # 1+2+...+10 = 55
```

**Why this works**:
- sum(5) = 5 + sum(4)
- sum(4) = 4 + sum(3)
- sum(3) = 3 + sum(2)
- sum(2) = 2 + sum(1)
- sum(1) = 1 + sum(0)
- sum(0) = 0 ‚Üê Base case stops the recursion

---

## üí° Common Patterns & Best Practices

### Pattern 1: Validation Functions

```python
def validate_input(value, min_val=0, max_val=100):
    """Common in data preprocessing"""
    if not isinstance(value, (int, float)):
        return False
    return min_val <= value <= max_val
```

### Pattern 2: Transformation Functions

```python
def normalize_expression(expression_value, mean, std):
    """Z-score normalization for gene expression"""
    return (expression_value - mean) / std
```

### Pattern 3: Aggregation Functions

```python
def calculate_average(values):
    """Calculate mean of a list"""
    if len(values) == 0:
        return None
    return sum(values) / len(values)
```

### Pattern 4: Higher-Order Functions (Preview)

```python
def apply_to_all(func, data_list):
    """Apply a function to every item in a list"""
    return [func(item) for item in data_list]

# Example usage
numbers = [1, 2, 3, 4, 5]
squared = apply_to_all(lambda x: x**2, numbers)
# [1, 4, 9, 16, 25]
```

---

## üö® Beginner Pitfalls to Avoid

### Pitfall 1: Forgetting to Call the Function

```python
# ‚ùå WRONG - Just defining, not using
def calculate_average(values):
    return sum(values) / len(values)
# Nothing happens!

# ‚úÖ CORRECT
result = calculate_average([1, 2, 3])
```

### Pitfall 2: Missing Base Case in Recursion

```python
# ‚ùå WRONG - Infinite recursion!
def countdown(n):
    print(n)
    countdown(n - 1)  # Never stops!

# ‚úÖ CORRECT
def countdown(n):
    if n == 0:  # Base case
        return
    print(n)
    countdown(n - 1)
```

### Pitfall 3: Confusing Parameters and Arguments

```python
def greet(name):  # 'name' is the parameter
    print(f"Hello, {name}")

greet()  # ‚ùå ERROR: Missing required argument
greet("Alice")  # ‚úÖ CORRECT: "Alice" is the argument
```

### Pitfall 4: Not Capturing Return Values

```python
def calculate(x):
    return x * 2

calculate(5)  # ‚ùå Result is lost!

result = calculate(5)  # ‚úÖ Captures return value
print(result)  # 10
```

### Pitfall 5: Modifying Global Variables (Advanced Warning)

```python
# ‚ùå BAD PRACTICE
total = 0

def add_to_total(value):
    global total  # Avoid this!
    total += value

# ‚úÖ BETTER - Pure function
def add_values(current_total, value):
    return current_total + value

total = add_values(total, 5)
```

---

## üî¨ Biomedical AI Context: Real-World Applications

### 1. Preprocessing Pipeline Functions

```python
def preprocess_clinical_data(patient_record):
    """
    Clean and standardize clinical data.
    Essential for ML model input.
    """
    # Remove missing values
    cleaned = remove_nulls(patient_record)
    
    # Normalize numerical features
    normalized = normalize_features(cleaned)
    
    # Encode categorical variables
    encoded = encode_categories(normalized)
    
    return encoded
```

### 2. Model Evaluation Functions

```python
def calculate_metrics(y_true, y_pred):
    """
    Calculate precision, recall, F1 for medical diagnosis model.
    Critical for assessing clinical utility.
    """
    from sklearn.metrics import precision_score, recall_score, f1_score
    
    return {
        'precision': precision_score(y_true, y_pred),
        'recall': recall_score(y_true, y_pred),
        'f1': f1_score(y_true, y_pred)
    }
```

### 3. Recursive Tree Traversal (Drug-Drug Interactions)

```python
def find_interaction_path(drug1, drug2, interaction_graph, path=[]):
    """
    Recursively find if two drugs have indirect interactions.
    Models complex biological networks.
    """
    path = path + [drug1]
    
    if drug1 == drug2:
        return path
    
    if drug1 not in interaction_graph:
        return None
    
    for node in interaction_graph[drug1]:
        if node not in path:  # Avoid cycles
            new_path = find_interaction_path(node, drug2, interaction_graph, path)
            if new_path:
                return new_path
    
    return None
```

---

## üìù Practice Problems (Essential for Mastery)

### Problem 1: Temperature Converter

```python
def celsius_to_fahrenheit(celsius):
    """Convert Celsius to Fahrenheit. Used in lab equipment."""
    # YOUR CODE HERE
    pass

# Test
print(celsius_to_fahrenheit(37))  # Should return 98.6
```

<details>
<summary>Solution</summary>

```python
def celsius_to_fahrenheit(celsius):
    return (celsius * 9/5) + 32
```
</details>

### Problem 2: BMI Calculator

```python
def calculate_bmi(weight_kg, height_m):
    """
    Calculate Body Mass Index.
    Used in clinical decision support systems.
    """
    # YOUR CODE HERE
    pass

# Test
print(calculate_bmi(70, 1.75))  # Should return ~22.86
```

<details>
<summary>Solution</summary>

```python
def calculate_bmi(weight_kg, height_m):
    if height_m <= 0:
        return None
    return weight_kg / (height_m ** 2)
```
</details>

### Problem 3: Recursive Power Function

```python
def power(base, exponent):
    """
    Calculate base^exponent recursively.
    Used in growth models, pharmacokinetics.
    """
    # YOUR CODE HERE
    # Hint: base^n = base * base^(n-1)
    # Base case: base^0 = 1
    pass

# Test
print(power(2, 3))  # Should return 8
```

<details>
<summary>Solution</summary>

```python
def power(base, exponent):
    if exponent == 0:
        return 1
    return base * power(base, exponent - 1)
```
</details>

### Problem 4: Check if Number is Odd/Even (Homework)

```python
def check_odd_even(n):
    """
    Return "odd" if number is odd, "even" if even.
    Simple but fundamental for data filtering.
    """
    # YOUR CODE HERE
    pass
```

---

## üéì What You Just Learned

### Functions Core Concepts
‚úÖ Functions eliminate code redundancy  
‚úÖ Parameters receive input, return sends output  
‚úÖ Default parameters make functions flexible  
‚úÖ Built-in functions (print, len) vs user-defined  
‚úÖ Good naming and documentation are critical  

### Recursion Core Concepts
‚úÖ Recursion = function calling itself  
‚úÖ Base case prevents infinite loops  
‚úÖ Call stack manages function execution  
‚úÖ Useful for tree/graph problems  
‚úÖ Often has loop-based alternatives  

### Production ML Relevance
‚úÖ Modular code is maintainable  
‚úÖ Functions enable testing and debugging  
‚úÖ Reusability accelerates development  
‚úÖ Essential for pipeline architecture  

---

## üöÄ Next Steps & Learning Path

### Immediate Practice (This Week)
1. Solve all 4 practice problems above
2. Rewrite previous loop-based code using functions
3. Create a small biomedical utility library:
   ```python
   # my_biomedical_utils.py
   def normalize_expression(value, mean, std):
       pass
   
   def calculate_gc_content(sequence):
       pass
   
   def validate_patient_id(patient_id):
       pass
   ```

### Short-term Goals (Next 2 Weeks)
1. Learn **lambda functions** (anonymous functions)
2. Understand **scope** (local vs global variables)
3. Study **decorators** (functions that modify functions)
4. Practice **error handling** in functions (try/except)

### Medium-term Goals (Next Month)
1. Master **functional programming** concepts (map, filter, reduce)
2. Learn **generator functions** (memory-efficient iteration)
3. Study **closures** and **partial functions**
4. Build a complete data preprocessing pipeline using functions

### Resources for Deeper Learning
- **Interactive**: [Python Tutor](http://pythontutor.com) - Visualize recursion
- **Practice**: [LeetCode](https://leetcode.com) - Filter by "Easy" + "Recursion"
- **Biomedical**: [Rosalind](http://rosalind.info) - Bioinformatics problems
- **Book**: "Fluent Python" by Luciano Ramalho (Chapter 5: First-Class Functions)

---

## üìä Visual Summary

```
FUNCTIONS                          RECURSION
========                          =========
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               Function calls itself:
‚îÇ  Input (args)   ‚îÇ               
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               show(5) ‚Üí show(4) ‚Üí show(3)
         ‚îÇ                                    ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           show(2)
    ‚îÇ  Logic  ‚îÇ                              ‚Üì
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           show(1)
         ‚îÇ                                   ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      show(0) ‚Üê BASE CASE
‚îÇ Output (return) ‚îÇ                         ‚Üì
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                     Returns back up

WHY USE?                          WHY USE?
- Eliminate redundancy           - Elegant for tree problems
- Modular code                   - Natural for recursive data
- Reusability                    - Divide-and-conquer
- Testability                    - Some problems are clearer

CAUTION:                          CAUTION:
- Name clearly                   - MUST have base case
- Document purpose               - Stack overflow risk
- Handle edge cases              - Usually slower than loops
```

---

## üß™ Advanced Preview: Functions in ML/AI Production

```python
# Example: Production-style preprocessing function
def preprocess_medical_image(
    image_path: str,
    target_size: tuple = (224, 224),
    normalize: bool = True,
    augment: bool = False
) -> np.ndarray:
    """
    Preprocess medical image for model inference.
    
    Args:
        image_path: Path to input image
        target_size: Resize dimensions
        normalize: Apply intensity normalization
        augment: Apply data augmentation
    
    Returns:
        Preprocessed image as numpy array
    
    Raises:
        FileNotFoundError: If image_path doesn't exist
        ValueError: If image format unsupported
    """
    # Load image
    img = load_image(image_path)
    
    # Resize
    img = resize(img, target_size)
    
    # Normalize
    if normalize:
        img = normalize_intensity(img)
    
    # Augment
    if augment:
        img = apply_augmentation(img)
    
    return img
```

This is where you're headed - writing production-grade functions for biomedical AI systems!

---

**Remember**: Functions and recursion are fundamental building blocks. Master these, and complex AI pipelines become manageable. Don't rush - deep understanding now saves weeks of confusion later.

*Keep practicing, keep building, and embrace the challenge of recursion - it's a rite of passage for every programmer!* üöÄ
