# Python Dictionaries & Sets: Complete Guide for Biomedical AI

## Prerequisites Check
- **Required**: Basic Python syntax (variables, data types)
- **Helpful**: Understanding of lists and tuples
- **No prior knowledge needed**: Data structures, hash tables, or advanced CS concepts

---

## Key Takeaways
1. **Dictionaries** store key-value pairs (like real dictionaries: wordâ†’meaning)
2. **Sets** store unique, unordered collections (no duplicates allowed)
3. Both are **mutable** (can be changed) but have different use cases
4. Critical for data processing in biomedical AI: patient records, feature mappings, deduplication
5. Performance: O(1) lookup time makes them essential for large-scale data

---

## Intuitive Overview

### Think of Dictionaries Like...
A **medical chart**: Each patient (key) has their records (values). You look up by patient ID, not by flipping through every page.

```
Patient_ID â†’ {name, age, diagnosis, medications}
Gene_Symbol â†’ {location, function, disease_associations}
```

### Think of Sets Like...
A **unique patient cohort**: You can't have the same patient twice. Order doesn't matter; what matters is membership.

```
{patients_with_diabetes} âˆ© {patients_over_50} = patients needing specific screening
```

---

## Part 1: Dictionaries (Detailed Deep Dive)

### 1.1 What Are Dictionaries?

**Conceptual Model**: 
- Real dictionary: word â†’ meanings
- Python dictionary: key â†’ value
- The **key** is your search term (like a unique identifier)
- The **value** is what you retrieve (can be anything)

**Why They Matter in Biomedical AI**:
- Store patient metadata (ID â†’ patient data)
- Map protein names to sequences
- Store model hyperparameters
- Cache computed features
- Configuration files for ML pipelines

### 1.2 Creating Dictionaries

```python
# Basic syntax: curly braces with key:value pairs
info = {
    "name": "Apna College",
    "age": 35,
    "is_adult": True,
    "marks": 94.4
}

# Empty dictionary (two ways)
empty_dict = {}  # This is a dictionary!
empty_set = set()  # Sets need this syntax

# Biomedical example: Patient record
patient = {
    "patient_id": "P001",
    "age": 45,
    "diagnosis": "Type 2 Diabetes",
    "medications": ["Metformin", "Insulin"],
    "biomarkers": {"HbA1c": 7.5, "glucose": 140}
}
```

**Key Rules**:
- Keys must be **immutable** (strings, numbers, tuples - NOT lists/dicts)
- Keys must be **unique** (duplicates overwrite)
- Values can be **anything** (including lists, dicts, objects)

### 1.3 Accessing Dictionary Values

```python
student = {
    "name": "Rahul Kumar",
    "subjects": ["Python", "C", "Java"],
    "topics": ("Dictionary", "Sets")
}

# Access by key
print(student["name"])  # Output: Rahul Kumar
print(student["subjects"])  # Output: ['Python', 'C', 'Java']

# âŒ PROBLEM: KeyError if key doesn't exist
print(student["surname"])  # KeyError: 'surname'

# âœ… SOLUTION: Use .get() method
print(student.get("surname"))  # Output: None (no error!)
print(student.get("surname", "Not Found"))  # Output: Not Found
```

**Critical Insight for Production Code**:
```python
# ğŸš« BAD: Can crash your entire program
def process_patient(data):
    diagnosis = data["diagnosis"]  # Crashes if key missing
    # ... rest of code never executes
    
# âœ… GOOD: Graceful handling
def process_patient(data):
    diagnosis = data.get("diagnosis", "Unknown")  # Safe default
    # ... code continues even if key is missing
```

### 1.4 Modifying Dictionaries

```python
info = {"name": "Apna College"}

# Add new key-value pair
info["surname"] = "Kumar"

# Update existing value
info["name"] = "New Name"  # Overwrites old value

# Note: Dictionaries are MUTABLE
print(info)  # {'name': 'New Name', 'surname': 'Kumar'}
```

**Biomedical Application**: Updating patient records
```python
patient_records = {}

# Add patient data dynamically
patient_records["P001"] = {
    "diagnosis": "Hypertension",
    "date": "2025-01-15"
}

# Update with new lab results
patient_records["P001"]["lab_results"] = {
    "BP": "140/90",
    "cholesterol": 220
}
```

### 1.5 Nested Dictionaries

**When to use**: Hierarchical data (common in biomedical datasets!)

```python
student = {
    "name": "Rahul Kumar",
    "subjects": {
        "physics": 98,
        "chemistry": 87,
        "math": 95
    }
}

# Access nested values
print(student["subjects"]["chemistry"])  # Output: 87

# Biomedical example: Clinical trial data
trial_data = {
    "trial_id": "NCT12345",
    "participants": {
        "P001": {
            "baseline": {"weight": 85, "BP": "130/85"},
            "week_12": {"weight": 78, "BP": "120/80"}
        },
        "P002": {
            "baseline": {"weight": 92, "BP": "140/90"},
            "week_12": {"weight": 88, "BP": "125/82"}
        }
    }
}

# Extract specific patient data
p001_bp_change = (
    trial_data["participants"]["P001"]["week_12"]["BP"],
    trial_data["participants"]["P001"]["baseline"]["BP"]
)
```

### 1.6 Essential Dictionary Methods

#### `.keys()` - Get all keys
```python
student = {"name": "Rahul", "subjects": {"physics": 98}}

keys = student.keys()  # dict_keys(['name', 'subjects'])
keys_list = list(student.keys())  # ['name', 'subjects']

# Length of dictionary
print(len(student))  # 2 (number of key-value pairs)
```

**Biomedical use case**: Get all gene symbols in a dataset
```python
gene_expression = {
    "BRCA1": 5.2,
    "TP53": 3.8,
    "EGFR": 7.1
}

all_genes = list(gene_expression.keys())
print(f"Analyzing {len(all_genes)} genes")
```

#### `.values()` - Get all values
```python
values = student.values()  # dict_values(['Rahul', {...}])
values_list = list(student.values())
```

#### `.items()` - Get key-value pairs as tuples
```python
items = student.items()  
# dict_items([('name', 'Rahul'), ('subjects', {...})])

items_list = list(student.items())
# [('name', 'Rahul'), ('subjects', {...})]

# Access first pair
first_pair = items_list[0]  # ('name', 'Rahul')
```

**Powerful pattern** (preview of loops):
```python
# Future: Iterate through all key-value pairs
for key, value in gene_expression.items():
    print(f"Gene {key} has expression level {value}")
```

#### `.update()` - Add/modify multiple items
```python
student = {"name": "Rahul"}

# Add multiple key-value pairs at once
student.update({
    "city": "Delhi",
    "age": 16
})

# Or update with another dictionary
new_data = {"city": "Mumbai", "grade": "A"}
student.update(new_data)  # Overwrites city, adds grade
```

**Biomedical example**: Merging lab results
```python
patient = {"id": "P001", "name": "John"}

# Add lab results
lab_results = {
    "glucose": 110,
    "cholesterol": 200,
    "BP": "120/80"
}
patient.update(lab_results)

# Update with new test
patient.update({"HbA1c": 5.6})
```

---

## Part 2: Sets (Complete Guide)

### 2.1 What Are Sets?

**Mathematical concept**: Collection of **unique**, **unordered** elements

**Key properties**:
1. **Unordered**: No indexing (no `set[0]`)
2. **Unique**: Duplicates automatically removed
3. **Mutable**: Can add/remove elements
4. **Immutable elements**: Can only contain hashable types

**Real-world analogy**: 
- A clinical study cohort: each patient appears once
- Unique diagnoses in a database
- Set of genes affected by a drug

### 2.2 Creating Sets

```python
# Basic syntax: curly braces (like dict, but no key:value)
collection = {1, 2, 3, 4}
print(collection)  # {1, 2, 3, 4} (order may vary!)

# With strings
collection = {1, 2, "hello", "world"}

# Duplicates are ignored
collection = {1, 2, 2, 2, 3, 3}
print(collection)  # {1, 2, 3} - only unique values!

# Empty set (special syntax!)
empty_set = set()  # NOT {}
empty_dict = {}    # This is a dictionary!

print(type(empty_set))   # <class 'set'>
print(type(empty_dict))  # <class 'dict'>
```

**Critical: Order is unpredictable**
```python
nums = {1, 2, 3, 4, "hello"}
print(nums)  # Order varies each time!
# Could be: {1, 2, 'hello', 3, 4}
# Or: {'hello', 1, 2, 3, 4}
```

### 2.3 What Can/Cannot Go in Sets

```python
# âœ… ALLOWED: Immutable types
valid_set = {
    1,              # int
    2.5,            # float
    "text",         # string
    True,           # boolean
    (1, 2, 3)       # tuple
}

# âŒ NOT ALLOWED: Mutable types
invalid_set = {
    [1, 2, 3],      # list - TypeError!
    {"key": "val"}  # dict - TypeError!
}
```

**Why this matters**: Hashability requirement
```python
# Sets use hash values internally for O(1) lookup
# Mutable objects can change â†’ hash changes â†’ breaks set logic

# Example: Why lists don't work
list1 = [1, 2, 3]
# If we could add to set, then:
list1.append(4)  # Now [1, 2, 3, 4]
# Hash would change! Set wouldn't know where to find it
```

### 2.4 Set Operations

#### Adding elements
```python
collection = {1, 2, 3}

# Add single element
collection.add(4)
print(collection)  # {1, 2, 3, 4}

# Add duplicate (ignored)
collection.add(2)
print(collection)  # {1, 2, 3, 4} - still only one 2

# Can add tuples
collection.add((5, 6))
print(collection)  # {1, 2, 3, 4, (5, 6)}
```

#### Removing elements
```python
collection = {1, 2, 3, 4}

# Remove specific element
collection.remove(2)
print(collection)  # {1, 3, 4}

# Remove non-existent element â†’ KeyError!
collection.remove(7)  # KeyError: 7

# Pop random element
removed = collection.pop()
print(removed)  # Could be any element (1, 3, or 4)
print(collection)  # Remaining elements
```

#### Clearing set
```python
collection = {1, 2, 3, 4}
print(len(collection))  # 4

collection.clear()
print(len(collection))  # 0
print(collection)       # set()
```

### 2.5 Set Mathematics (Crucial for Data Science!)

#### Union: Combine sets (all unique elements)
```python
set1 = {1, 2, 3}
set2 = {3, 4, 5}

union = set1.union(set2)
print(union)  # {1, 2, 3, 4, 5}

# Original sets unchanged
print(set1)  # {1, 2, 3}
print(set2)  # {3, 4, 5}
```

**Visual representation**:
```
set1: {1, 2, 3}
set2:       {3, 4, 5}
union: {1, 2, 3, 4, 5}  â† All unique elements
```

#### Intersection: Common elements only
```python
set1 = {1, 2, 3}
set2 = {2, 3, 4}

intersection = set1.intersection(set2)
print(intersection)  # {2, 3}
```

**Visual representation**:
```
set1: {1, 2, 3}
set2:    {2, 3, 4}
intersection: {2, 3}  â† Only common elements
```

**Biomedical AI Application**:
```python
# Patients in different studies
diabetes_patients = {"P001", "P002", "P003", "P005"}
hypertension_patients = {"P002", "P003", "P004", "P006"}

# Union: All patients in either study
all_patients = diabetes_patients.union(hypertension_patients)
print(f"Total unique patients: {len(all_patients)}")

# Intersection: Patients with both conditions
comorbid = diabetes_patients.intersection(hypertension_patients)
print(f"Patients with both conditions: {comorbid}")

# Genes targeted by two drugs
drug_a_targets = {"BRCA1", "TP53", "EGFR", "MYC"}
drug_b_targets = {"EGFR", "MYC", "KRAS", "ALK"}

common_targets = drug_a_targets.intersection(drug_b_targets)
print(f"Shared targets: {common_targets}")  # {'EGFR', 'MYC'}
```

---

## Biomedical AI Applications

### 1. Patient Data Management
```python
# Dictionary: Store patient records
patient_db = {
    "P001": {
        "name": "John Doe",
        "age": 45,
        "conditions": ["diabetes", "hypertension"],
        "medications": {
            "metformin": {"dose": "500mg", "frequency": "2x/day"},
            "lisinopril": {"dose": "10mg", "frequency": "1x/day"}
        }
    }
}

# Access specific patient data
patient_meds = patient_db["P001"]["medications"]
```

### 2. Gene Expression Analysis
```python
# Dictionary: Map genes to expression levels
gene_expression = {
    "BRCA1": 5.2,
    "TP53": 3.8,
    "EGFR": 7.1,
    "MYC": 6.3
}

# Set: Find unique genes across samples
sample1_genes = {"BRCA1", "TP53", "EGFR"}
sample2_genes = {"TP53", "EGFR", "MYC", "KRAS"}

# Genes expressed in both samples
common_genes = sample1_genes.intersection(sample2_genes)
# All expressed genes
all_genes = sample1_genes.union(sample2_genes)
```

### 3. Feature Engineering for ML
```python
# Dictionary: Store feature mappings
feature_map = {
    "age": 0,
    "bmi": 1,
    "glucose": 2,
    "bp_systolic": 3
}

# Set: Track which features are categorical
categorical_features = {"gender", "smoking_status", "diagnosis"}
numerical_features = {"age", "bmi", "glucose"}
```

### 4. Deduplication in Data Processing
```python
# Use set to remove duplicate patient IDs
all_patient_ids = [
    "P001", "P002", "P003", "P001",  # P001 is duplicate
    "P004", "P002", "P005"           # P002 is duplicate
]

unique_patients = set(all_patient_ids)
print(f"Unique patients: {len(unique_patients)}")  # 5, not 7
```

### 5. Model Configuration
```python
# Dictionary: Store model hyperparameters
model_config = {
    "learning_rate": 0.001,
    "batch_size": 32,
    "epochs": 100,
    "architecture": {
        "input_dim": 512,
        "hidden_layers": [256, 128, 64],
        "output_dim": 10
    }
}

# Easy to update
model_config.update({"learning_rate": 0.0001})
```

---

## Common Patterns & Best Practices

### 1. Safe Dictionary Access Pattern
```python
# âŒ Risky
def get_patient_age(patient_dict):
    return patient_dict["age"]  # Crashes if "age" missing

# âœ… Safe with default
def get_patient_age(patient_dict):
    return patient_dict.get("age", 0)  # Returns 0 if missing

# âœ… Safe with error handling (advanced)
def get_patient_age(patient_dict):
    try:
        return patient_dict["age"]
    except KeyError:
        print("Age not found, using default")
        return 0
```

### 2. Building Dictionaries Incrementally
```python
# Start with empty dictionary
patient_data = {}

# Add data as it becomes available
patient_data["id"] = "P001"
patient_data["age"] = 45
patient_data["diagnosis"] = "diabetes"

# Or use update for multiple items
patient_data.update({
    "medications": ["metformin"],
    "last_visit": "2025-01-15"
})
```

### 3. Set Deduplication Pattern
```python
# Remove duplicates from list using set
patient_list = ["P001", "P002", "P001", "P003", "P002"]
unique_patients = list(set(patient_list))
print(unique_patients)  # ['P001', 'P002', 'P003']

# Count unique items
num_unique = len(set(patient_list))
```

### 4. Dictionary Comprehension (Preview)
```python
# Future skill: Create dictionary from lists
gene_names = ["BRCA1", "TP53", "EGFR"]
expression = [5.2, 3.8, 7.1]

# This creates: {"BRCA1": 5.2, "TP53": 3.8, "EGFR": 7.1}
gene_dict = {name: expr for name, expr in zip(gene_names, expression)}
```

---

## Beginner Pitfalls to Avoid

### 1. Empty Dictionary vs Empty Set
```python
# âŒ WRONG: This creates a dictionary, not a set!
empty = {}
print(type(empty))  # <class 'dict'>

# âœ… CORRECT: Use set() for empty set
empty_set = set()
print(type(empty_set))  # <class 'set'>
```

### 2. Assuming Sets Are Ordered
```python
# âŒ WRONG: Don't rely on order
nums = {1, 2, 3, 4, 5}
first = nums[0]  # TypeError: 'set' object is not subscriptable

# âœ… CORRECT: Convert to list if order matters
nums_list = sorted(list(nums))
first = nums_list[0]
```

### 3. Trying to Use Mutable Objects as Keys/Set Members
```python
# âŒ WRONG: Lists can't be dictionary keys
patient_records = {
    ["P001", "John"]: {"age": 45}  # TypeError!
}

# âœ… CORRECT: Use tuples instead
patient_records = {
    ("P001", "John"): {"age": 45}  # Works!
}

# âŒ WRONG: Can't add list to set
my_set = {[1, 2, 3]}  # TypeError!

# âœ… CORRECT: Use tuple
my_set = {(1, 2, 3)}  # Works!
```

### 4. Forgetting .get() Causes Crashes
```python
# âŒ DANGEROUS: Code stops if key missing
patient = {"name": "John"}
age = patient["age"]  # KeyError: 'age'
print("This never executes")  # Never runs!

# âœ… SAFE: Code continues
patient = {"name": "John"}
age = patient.get("age", 0)
print("This executes")  # Runs successfully
```

### 5. Float vs Int in Sets
```python
# Subtle: Python treats 9 and 9.0 as same in sets
values = {9, 9.0}
print(values)  # {9} - only one value!

# Solution: Use strings if you need both
values = {9, "9.0"}  # {9, '9.0'} - two distinct values
```

---

## Practice Problems (With Solutions)

### Problem 1: Word Meanings
**Task**: Store word meanings in dictionary

```python
dictionary = {
    "table": ["a piece of furniture", "list of facts & figures"],
    "cat": ["a small animal"]
}

print(dictionary["table"])  # ['a piece of furniture', 'list of facts & figures']
```

### Problem 2: Classroom Calculator
**Task**: How many unique classrooms needed?

```python
# Student subjects
subjects = {
    "python", "java", "C++", "python",
    "javascript", "java", "python",
    "java", "C++", "C"
}

# Set automatically removes duplicates
num_classrooms = len(subjects)
print(f"Classrooms needed: {num_classrooms}")  # 5

# Unique subjects
print(f"Subjects: {subjects}")
# {'python', 'java', 'C++', 'javascript', 'C'}
```

### Problem 3: User Input to Dictionary
**Task**: Enter marks for 3 subjects

```python
marks = {}  # Start with empty dictionary

# Get input from user
physics = int(input("Enter physics marks: "))
marks.update({"physics": physics})

math = int(input("Enter math marks: "))
marks.update({"math": math})

chemistry = int(input("Enter chemistry marks: "))
marks.update({"chemistry": chemistry})

print(marks)
# Example: {'physics': 95, 'math': 88, 'chemistry': 92}
```

### Problem 4: Store 9 and 9.0 Separately
**Task**: Store both values in a set

```python
# Problem: Python treats 9 and 9.0 as identical
values = {9, 9.0}
print(values)  # {9} - only one value!

# Solution 1: Use string for one
values = {9, "9.0"}
print(values)  # {9, '9.0'}

# Solution 2: Store with type information as tuple
values = {(int, 9), (float, 9.0)}
print(values)  # {(int, 9), (float, 9.0)}
```

---

## Visual Diagrams

### Dictionary Structure
```
Dictionary: patient_data
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Key          â†’    Value          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ "id"         â†’    "P001"         â”‚
â”‚ "age"        â†’    45              â”‚
â”‚ "diagnosis"  â†’    "diabetes"     â”‚
â”‚ "labs"       â†’    {dict}         â”‚
â”‚                   â”œâ”€ "glucose": 110
â”‚                   â””â”€ "BP": "120/80"
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Set Operations Visual
```
Set Union (OR logic)
  A = {1, 2, 3}
  B = {3, 4, 5}
  
  A âˆª B = {1, 2, 3, 4, 5}
  
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  1   3 â”€â”¼â”€â”€ 4  â”‚
  â”‚    2    â”‚   5   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
      A         B

Set Intersection (AND logic)
  A = {1, 2, 3}
  B = {2, 3, 4}
  
  A âˆ© B = {2, 3}
  
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  1 â”Œâ”€2â”€â”â”‚
  â”‚    â””â”€3â”€â”˜â”‚ 4 â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”˜
      A     B
```

---

## What You Just Learned

### New Concepts Mastered
1. âœ… Dictionaries: Key-value pair storage
2. âœ… Dictionary methods: `.get()`, `.keys()`, `.values()`, `.items()`, `.update()`
3. âœ… Nested dictionaries: Hierarchical data structures
4. âœ… Sets: Unique, unordered collections
5. âœ… Set operations: Union, intersection
6. âœ… Mutability: What can/can't be changed
7. âœ… Hashability: Why lists can't be in sets

### Skills Developed
- Safe data access patterns (`.get()` vs `[]`)
- Deduplication with sets
- Building complex data structures
- Real-world biomedical data modeling

---

## Summary & Next Steps

### What Makes Dict/Sets Powerful
- **Fast lookup**: O(1) time complexity
- **Flexible**: Store any data type as values
- **Practical**: Model real-world relationships
- **Essential**: Foundation for pandas, data processing

### Next Learning Steps
1. **Loops** (for, while): Iterate through dictionaries and sets
2. **Functions**: Encapsulate dict/set operations
3. **List comprehensions**: Create dicts/sets elegantly
4. **Try-except**: Robust error handling
5. **JSON**: Dictionaries in file format
6. **Pandas DataFrames**: Advanced dictionary-like structures

### Biomedical AI Next Steps
1. Practice with real datasets:
   - Parse patient JSON data
   - Process gene expression files
   - Build drug-target mappings
   
2. Explore libraries that use dict/sets:
   - `json`: Load/save data
   - `collections`: OrderedDict, defaultdict, Counter
   - `pandas`: DataFrames (dict-like)
   
3. Build projects:
   - Patient record database
   - Gene set enrichment analysis
   - Drug interaction checker

### Additional Resources
- **Python Docs**: https://docs.python.org/3/tutorial/datastructures.html
- **Real Python**: Dictionary tutorials
- **Biomedical datasets**: NCBI, UniProt (practice parsing)
- **Next video**: Loops (to fully unlock dict/set power!)

---

## Quick Reference Cheat Sheet

```python
# DICTIONARIES
d = {"key": "value"}              # Create
d["key"]                          # Access (can crash)
d.get("key", "default")           # Safe access
d["new_key"] = "new_value"        # Add/update
d.keys()                          # All keys
d.values()                        # All values
d.items()                         # Key-value pairs
d.update({"k": "v"})              # Bulk update
len(d)                            # Number of pairs

# SETS
s = {1, 2, 3}                     # Create
s = set()                         # Empty set
s.add(4)                          # Add element
s.remove(2)                       # Remove (crash if missing)
s.pop()                           # Remove random
s.clear()                         # Empty set
len(s)                            # Number of elements
s1.union(s2)                      # Combine sets
s1.intersection(s2)               # Common elements
```

---

**Remember**: 
- Dictionaries = labeled storage (keyâ†’value)
- Sets = unique collections (no duplicates)
- Use `.get()` in production code
- Sets are perfect for deduplication

**You're ready to process biomedical data like a pro!** ğŸ§¬ğŸ’»ğŸ”¬
