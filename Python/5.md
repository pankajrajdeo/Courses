# Python Loops: Complete Guide for Biomedical AI Engineers

## 🎯 Key Takeaways

- **Loops eliminate repetition**: Instead of copying code 100,000 times, write it once and loop
- **Two main types**: `while` (condition-based) and `for` (iteration-based)
- **Control flow keywords**: `break` (exit loop), `continue` (skip current iteration), `pass` (placeholder)
- **Biomedical relevance**: Process millions of patient records, genomic sequences, medical images, and molecular structures efficiently
- **Production systems**: Essential for batch processing, data pipelines, and model training loops

---

## 📋 Prerequisites Check

### Assumed Knowledge (Will Build From Scratch):
- ✅ Basic Python syntax (variables, print statements)
- ✅ Data types (strings, integers, lists, tuples)
- ✅ Basic conditionals (if/else)
- ✅ Indexing concepts

### What You'll Learn:
- ❌ **NEW**: Loop mechanics and iteration patterns
- ❌ **NEW**: Iterator variables and stopping conditions
- ❌ **NEW**: Sequential traversal strategies
- ❌ **NEW**: Algorithm efficiency concepts

---

## 🧠 Intuitive Overview: Why Loops Matter

### The Problem Without Loops

Imagine you need to send emails to 100,000 patients about their lab results. Without loops:

```python
# This is madness! ❌
send_email(user1)
send_email(user2)
send_email(user3)
# ... 99,997 more lines ...
send_email(user100000)
```

**Problems:**
1. **Unmaintainable**: File becomes enormous
2. **Error-prone**: Manual repetition invites mistakes
3. **Inflexible**: Change logic? Edit 100,000 lines!
4. **Tedious**: Wastes developer time

### The Solution: Loops

```python
# Elegant! ✅
for user in all_users:
    send_email(user)
```

**Benefits:**
- One location to update logic
- Scales from 10 to 10 million users
- Readable and maintainable
- Professional standard

### Real-World Biomedical Analogy

Think of loops like a **medical diagnostic scanner**:
- **Without loops**: Doctor examines one cell, records findings, examines next cell, records findings... (exhausting!)
- **With loops**: Scanner automatically processes all cells, applying the same diagnostic logic to each one

---

## 🔄 Part 1: While Loops - Condition-Based Repetition

### Mental Model

A `while` loop says: **"Keep doing this task as long as this condition is TRUE"**

```
┌─────────────────────────────┐
│  Check Condition            │
│  ↓                          │
│  Is it TRUE?                │
│  ├─ YES → Execute code      │
│  │         Update variables │
│  │         ↑                │
│  │         └────────────────┘
│  └─ NO → Exit loop          │
└─────────────────────────────┘
```

### Basic Syntax Pattern

```python
# Initialize iterator (starting point)
count = 1

# Condition (stopping criteria)
while count <= 5:
    # Work to perform
    print("Hello")
    
    # Update iterator (prevent infinite loop!)
    count += 1
```

**Anatomy of a While Loop:**
1. **Iterator**: Variable that tracks progress (`count`)
2. **Condition**: Boolean expression that determines continuation
3. **Work**: Code block to execute repeatedly
4. **Update**: Modify iterator to eventually make condition FALSE

---

### Example 1: Print "Hello" 5 Times

```python
count = 1  # Start counting from 1

while count <= 5:  # Continue while count is 5 or less
    print("Hello")
    count += 1  # Increment by 1 each time

# Output:
# Hello
# Hello
# Hello
# Hello
# Hello
```

**Execution Trace:**
```
Iteration 1: count=1, 1<=5? YES → print "Hello", count becomes 2
Iteration 2: count=2, 2<=5? YES → print "Hello", count becomes 3
Iteration 3: count=3, 3<=5? YES → print "Hello", count becomes 4
Iteration 4: count=4, 4<=5? YES → print "Hello", count becomes 5
Iteration 5: count=5, 5<=5? YES → print "Hello", count becomes 6
Iteration 6: count=6, 6<=5? NO  → EXIT LOOP
```

---

### Example 2: Print Numbers 1 to 100

```python
i = 1  # Short variable name (convention: i, j, k for iterators)

while i <= 100:
    print(i)
    i += 1

print("Loop ended")
```

**Why this works:**
- Starts at 1 (first number we want)
- Continues while i ≤ 100 (includes 100)
- Increments by 1 each time (sequential)

---

### Example 3: Reverse Order (100 to 1)

```python
i = 100  # Start from highest

while i >= 1:  # Continue until we reach 1
    print(i)
    i -= 1  # Decrement instead of increment

print("Loop ended")
```

**Key insight**: Change starting point, condition, and update direction for reverse iteration.

---

### Example 4: Multiplication Table

**Problem:** Print multiplication table for any number `n`

**Logic Breakdown:**
```
3 × 1 = 3
3 × 2 = 6
3 × 3 = 9
...
3 × 10 = 30
```

**Pattern Recognition:**
- First operand (3) stays constant
- Second operand (1, 2, 3...) changes from 1 to 10
- Second operand is our iterator!

```python
n = int(input("Enter number: "))
i = 1

while i <= 10:
    print(n * i)
    i += 1

# User enters 3:
# Output: 3, 6, 9, 12, 15, 18, 21, 24, 27, 30
```

---

### ⚠️ Beginner Pitfall #1: Infinite Loops

```python
# DANGER: Infinite loop! ❌
i = 5
while i > 0:
    print(i)
    i += 1  # i keeps getting BIGGER, never reaches 0!
```

**What happens:** 
- i = 5, 6, 7, 8... infinity
- Condition `i > 0` is ALWAYS true
- Loop never stops!
- Browser/terminal crashes

**Fix:** Ensure iterator moves toward stopping condition

```python
# CORRECT ✅
i = 5
while i > 0:
    print(i)
    i -= 1  # Now i decreases: 5, 4, 3, 2, 1, then stops
```

**Rule of Thumb:** If incrementing, use `<` or `<=`. If decrementing, use `>` or `>=`.

---

### Example 5: Traversing a List

**Problem:** Print all elements in a list

```python
numbers = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

idx = 0  # Start at first index

while idx < len(numbers):  # Continue until end
    print(numbers[idx])
    idx += 1

# Output: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
```

**Why `idx < len(numbers)` not `<=`?**
- List with 10 elements has indices 0-9
- `len(numbers)` = 10
- Last valid index = 9 = `len(numbers) - 1`
- Using `<` naturally stops at index 9

---

### Example 6: Searching in a Tuple (Linear Search)

**Problem:** Find number `x` in a tuple and print its index

```python
nums = (1, 4, 9, 16, 25, 36, 49, 36, 64, 81, 100)
x = 36
idx = 0

while idx < len(nums):
    if nums[idx] == x:
        print(f"Found at index {idx}")
        break  # Stop searching once found
    idx += 1

print("End of loop")
```

**Algorithm: Linear Search**
- Check each element sequentially
- Compare with target
- If match, report and stop
- If no match, continue to next

**Time Complexity:** O(n) - must potentially check every element

**Biomedical Application:** Searching for specific gene sequences, patient IDs, drug compounds in databases

---

## 🎮 Loop Control Keywords

### 1. `break` - Emergency Exit

**Purpose:** Immediately exit the loop, no matter what

```python
i = 1
while i <= 5:
    if i == 3:
        break  # Exit when i equals 3
    print(i)
    i += 1

print("Loop ended")

# Output:
# 1
# 2
# Loop ended
# (3, 4, 5 never printed)
```

**Biomedical Use Case:** Stop processing medical images once you find an anomaly

```python
for scan in mri_scans:
    if detect_tumor(scan):
        alert_radiologist(scan)
        break  # Stop checking, urgent case found!
    # Don't need to check remaining scans
```

---

### 2. `continue` - Skip Current Iteration

**Purpose:** Skip remaining code in current iteration, jump to next iteration

```python
i = 0
while i <= 10:
    i += 1
    if i == 3:
        continue  # Skip printing 3
    print(i)

# Output: 1, 2, 4, 5, 6, 7, 8, 9, 10, 11
# (3 is missing!)
```

**Difference from `break`:**
- `break`: Exit entire loop
- `continue`: Skip to next iteration

**Example: Print Only Odd Numbers**

```python
i = 0
while i <= 10:
    i += 1
    if i % 2 == 0:  # If even
        continue    # Skip to next iteration
    print(i)        # Only reached for odd numbers

# Output: 1, 3, 5, 7, 9
```

**Biomedical Use Case:** Filter out invalid data points

```python
for patient_record in dataset:
    if patient_record.has_missing_values():
        continue  # Skip invalid records
    process_for_analysis(patient_record)
```

---

## 🔁 Part 2: For Loops - Sequential Traversal

### Mental Model

A `for` loop says: **"For each item in this collection, do this work"**

```
Collection: [A, B, C, D, E]
           ↓
For each item:
  - Take item
  - Do work with item
  - Move to next automatically
```

**Key Difference from While:**
- **While**: You manage iterator manually
- **For**: Python handles iteration automatically

---

### Basic Syntax

```python
for element in collection:
    # Work with element
    print(element)
```

**Components:**
- `element`: Variable that holds current item (you choose the name)
- `in`: Keyword (part of syntax)
- `collection`: List, tuple, string, or range to iterate over

---

### Example 1: Iterate Over List

```python
numbers = [1, 2, 3, 4, 5]

for num in numbers:
    print(num)

# Output: 1, 2, 3, 4, 5
```

**What happens:**
```
Iteration 1: num = 1, print 1
Iteration 2: num = 2, print 2
Iteration 3: num = 3, print 3
Iteration 4: num = 4, print 4
Iteration 5: num = 5, print 5
```

---

### Example 2: Iterate Over String

```python
text = "DNA"

for char in text:
    print(char)

# Output:
# D
# N
# A
```

**Biomedical Insight:** Process DNA/RNA sequences character by character

```python
dna_sequence = "ATCGATCGATCG"
gc_count = 0

for nucleotide in dna_sequence:
    if nucleotide in ['G', 'C']:
        gc_count += 1

gc_percentage = (gc_count / len(dna_sequence)) * 100
print(f"GC Content: {gc_percentage}%")
```

---

### Example 3: Optional `else` Clause

```python
for char in "APNACOLLEGE":
    if char == 'O':
        print("O found")
        break
else:
    # Only executes if loop completes WITHOUT break
    print("O not found")

# Output: O found
```

**When `else` executes:**
- Loop completes normally (no `break`): YES
- Loop exits via `break`: NO

**Use Case:** Confirm whether search succeeded

```python
target_gene = "BRCA1"
found = False

for gene in gene_database:
    if gene.name == target_gene:
        print(f"Found {target_gene}")
        found = True
        break
else:
    print(f"{target_gene} not found in database")
```

---

## 📊 The `range()` Function - Number Sequences

### What is `range()`?

Generates a sequence of numbers for iteration.

**Syntax Options:**

```python
range(stop)              # 0 to stop-1
range(start, stop)       # start to stop-1
range(start, stop, step) # start to stop-1, increment by step
```

---

### Option 1: Single Argument (stop)

```python
for i in range(5):
    print(i)

# Output: 0, 1, 2, 3, 4
```

**Defaults:**
- Start: 0 (implicitly)
- Stop: 5 (explicit)
- Step: 1 (implicitly)

---

### Option 2: Two Arguments (start, stop)

```python
for i in range(2, 10):
    print(i)

# Output: 2, 3, 4, 5, 6, 7, 8, 9
```

**Note:** Stop value (10) is NEVER included!

---

### Option 3: Three Arguments (start, stop, step)

```python
for i in range(2, 10, 2):
    print(i)

# Output: 2, 4, 6, 8
```

**Step = 2:** Increment by 2 each time

---

### Reverse Iteration with Negative Step

```python
for i in range(100, 0, -1):
    print(i)

# Output: 100, 99, 98, ..., 2, 1
```

**Key Points:**
- Start: 100 (highest)
- Stop: 0 (exclusive, so stops at 1)
- Step: -1 (decrement)

---

### Example: Print Even Numbers 1-100

```python
for i in range(2, 101, 2):
    print(i)

# Output: 2, 4, 6, 8, ..., 98, 100
```

**Why 101?** Because stop is exclusive, we need 101 to include 100.

---

### Example: Print Odd Numbers 1-100

```python
for i in range(1, 101, 2):
    print(i)

# Output: 1, 3, 5, 7, ..., 97, 99
```

---

## 🎯 Practice Problems Walkthrough

### Problem 1: Sum of First N Numbers

**Problem:** Given N, calculate 1 + 2 + 3 + ... + N

```python
n = int(input("Enter number: "))
sum_total = 0

for i in range(1, n + 1):
    sum_total += i

print(f"Total sum: {sum_total}")

# n = 5: Output: 15 (1+2+3+4+5)
# n = 10: Output: 55
```

**Logic:**
1. Initialize accumulator (`sum_total = 0`)
2. Loop through each number
3. Add current number to accumulator
4. Print final result

**Biomedical Application:** Calculate total medication dosage over N days, sum signal intensities in imaging data

---

### Problem 2: Factorial of N

**Problem:** Calculate N! = 1 × 2 × 3 × ... × N

```python
n = int(input("Enter number: "))
factorial = 1  # MUST start at 1, not 0!

for i in range(1, n + 1):
    factorial *= i

print(f"Factorial: {factorial}")

# n = 5: Output: 120 (1×2×3×4×5)
# n = 4: Output: 24
# n = 3: Output: 6
```

**Critical Difference from Sum:**
- Sum: Initialize to 0 (additive identity)
- Product: Initialize to 1 (multiplicative identity)

**Why 1?** If you start at 0, everything multiplied by 0 equals 0!

**Biomedical Application:** Combinatorial calculations in genetics, probability calculations in clinical trials

---

### Problem 3: Search Element in Tuple

**Problem:** Find element X in tuple, print all indices where found

```python
nums = (1, 4, 9, 16, 25, 36, 49, 36, 64, 81, 100)
x = 36
idx = 0

for num in nums:
    if num == x:
        print(f"Found at index {idx}")
        break  # Remove break to find all occurrences
    idx += 1
```

**Enhancement: Track Index Automatically**

```python
for idx in range(len(nums)):
    if nums[idx] == x:
        print(f"Found at index {idx}")
```

---

## 🚫 The `pass` Statement - Placeholder

### What is `pass`?

A "do nothing" statement used as a placeholder.

```python
for i in range(5):
    pass  # Will implement logic later

print("Some useful work")
```

**Without `pass`:**

```python
for i in range(5):
    # ERROR! Python expects code here

print("Some useful work")
```

**Use Cases:**
1. Stubbing out functions/loops during development
2. Satisfying syntax requirements when you don't want to do anything
3. Exception handling (advanced topic)

```python
if patient.has_allergy():
    pass  # TODO: Implement allergy check logic
else:
    prescribe_medication()
```

---

## 🧬 Biomedical AI Applications

### 1. Processing Patient Records

```python
patient_database = load_patients()  # 1 million records

for patient in patient_database:
    # Extract features
    age = patient.age
    bmi = calculate_bmi(patient)
    risk_score = assess_risk(patient)
    
    # Store for ML model
    feature_vectors.append([age, bmi, risk_score])
```

---

### 2. Analyzing Genomic Sequences

```python
genome_sequence = load_fasta_file("human_chr1.fa")
window_size = 1000

# Sliding window analysis
for i in range(0, len(genome_sequence) - window_size, 100):
    window = genome_sequence[i:i+window_size]
    gc_content = calculate_gc(window)
    
    if gc_content > 0.6:
        print(f"High GC region at position {i}")
```

---

### 3. Processing Medical Images

```python
mri_scans = load_all_scans()

for scan in mri_scans:
    # Preprocess
    normalized = normalize_intensity(scan)
    augmented = apply_augmentation(normalized)
    
    # Extract features
    features = cnn_model.extract_features(augmented)
    
    # Store for training
    training_data.append((features, scan.label))
```

---

### 4. Drug Discovery - Molecular Screening

```python
compound_library = load_molecules()  # 10 million compounds
target_protein = load_target("EGFR")

high_affinity_compounds = []

for compound in compound_library:
    binding_affinity = calculate_binding(compound, target_protein)
    
    if binding_affinity < -8.0:  # Strong binder
        high_affinity_compounds.append(compound)
        
        if len(high_affinity_compounds) >= 100:
            break  # Stop after finding 100 candidates
```

---

### 5. Training Loop for Neural Networks

```python
num_epochs = 100
batch_size = 32

for epoch in range(num_epochs):
    epoch_loss = 0
    
    for batch_idx in range(0, len(training_data), batch_size):
        batch = training_data[batch_idx:batch_idx + batch_size]
        
        # Forward pass
        predictions = model(batch)
        loss = calculate_loss(predictions, batch.labels)
        
        # Backward pass
        loss.backward()
        optimizer.step()
        
        epoch_loss += loss.item()
    
    print(f"Epoch {epoch}: Loss = {epoch_loss / len(training_data)}")
```

---

## ⚠️ Common Pitfalls & Best Practices

### Pitfall 1: Off-by-One Errors

```python
# WRONG: Misses last element ❌
for i in range(len(data) - 1):
    process(data[i])

# CORRECT ✅
for i in range(len(data)):
    process(data[i])
```

---

### Pitfall 2: Modifying List While Iterating

```python
# DANGEROUS ❌
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num % 2 == 0:
        numbers.remove(num)  # Causes skipping!

# SAFE ✅
numbers = [1, 2, 3, 4, 5]
numbers = [num for num in numbers if num % 2 != 0]
```

---

### Pitfall 3: Unnecessary Nesting

```python
# INEFFICIENT ❌
for patient in patients:
    for gene in genes:
        for variant in variants:
            # O(n³) complexity!
            process(patient, gene, variant)

# BETTER ✅
# Precompute what you can
gene_variant_map = build_map(genes, variants)
for patient in patients:
    relevant_data = gene_variant_map[patient.id]
    process(patient, relevant_data)
```

---

## 📈 Performance Considerations

### Time Complexity

```python
# O(n) - Linear
for item in data:
    process(item)

# O(n²) - Quadratic (avoid when possible!)
for i in data:
    for j in data:
        compare(i, j)

# O(n log n) - Efficient sorting
sorted_data = sorted(data)
for item in sorted_data:
    process(item)
```

**Biomedical Context:**
- Processing 1M patient records: O(n) is acceptable
- Comparing every patient with every other: O(n²) = 1 trillion operations! (too slow)

---

## 🎓 What You Just Learned

### New Concepts Mastered:
✅ **While loops**: Condition-based repetition with manual iterator management  
✅ **For loops**: Automatic iteration over sequences  
✅ **Control flow**: `break`, `continue`, `pass`  
✅ **Range function**: Generating number sequences efficiently  
✅ **Linear search**: Sequential element finding  
✅ **Traversal patterns**: Lists, tuples, strings  
✅ **Accumulators**: Sum and product patterns  

### Skills Developed:
✅ Recognizing when to use while vs. for loops  
✅ Avoiding infinite loops  
✅ Implementing search algorithms  
✅ Processing collections efficiently  
✅ Building scalable data processing pipelines  

---

## 🚀 Next Steps

### Immediate Practice (Required):
1. **Rewrite examples**: Type every code example yourself
2. **Solve variations**: Change numbers, conditions, operations
3. **Debug intentionally**: Break code, understand errors
4. **Time yourself**: Track improvement in problem-solving speed

### Advanced Topics (Coming Soon):
- **List comprehensions**: Concise loop alternatives
- **Nested loops**: Multi-dimensional data processing
- **Generators**: Memory-efficient iteration
- **Vectorization**: NumPy/Pandas for performance
- **Parallel processing**: Multi-threading for biomedical pipelines

### Biomedical-Specific Learning:
- **BioPython loops**: Sequence analysis patterns
- **Pandas iteration**: DataFrame operations
- **Image processing**: Sliding windows, convolutions
- **Graph traversal**: Protein interaction networks
- **Time series**: Physiological signal processing

### Resources:
- **Practice**: LeetCode, HackerRank (loop problems)
- **Biomedical**: Rosalind.info (bioinformatics challenges)
- **Books**: "Python for Data Analysis" (Wes McKinney)
- **Documentation**: docs.python.org/tutorial/controlflow

---

## 💡 Final Wisdom

**Loop Mastery = Pattern Recognition + Practice**

Every complex biomedical AI system is built on these fundamentals. When you're training a model on 1M medical images or processing genomic data, you're ultimately just running sophisticated loops.

**Remember:**
- Start simple, build complexity gradually
- Every expert struggled with loops initially
- Biomedical AI is loops + domain knowledge
- Your non-technical background is an asset - you bring fresh perspectives!

**Keep practicing, keep building! 🧬🤖**
