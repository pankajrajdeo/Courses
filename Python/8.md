# Object-Oriented Programming in Python: From First Principles to Biomedical AI Applications

## 🎯 Key Takeaways

- **OOP is a programming paradigm** that models real-world entities as objects with properties (attributes) and behaviors (methods)
- **Classes are blueprints**, objects are instances - like a protein structure template vs. actual protein molecules
- **Four pillars of OOP**: Abstraction, Encapsulation, Inheritance, Polymorphism (this guide covers the first two)
- **Critical for biomedical AI**: Most ML frameworks (PyTorch, TensorFlow, Hugging Face) are built using OOP principles
- **Production systems**: Understanding OOP is essential for building scalable, maintainable AI applications

---

## 📋 Prerequisites Check

### What You Need to Know:
- ✅ Basic Python syntax (variables, functions, loops)
- ✅ Data structures (lists, dictionaries)
- ✅ Function definition and calling

### What You'll Learn:
- ✅ Classes and objects from scratch
- ✅ Constructors and the `self` parameter
- ✅ Instance vs. class attributes
- ✅ Methods (instance and static)
- ✅ Abstraction and encapsulation principles

---

## 🌉 Why OOP Matters for Biomedical AI

Before diving into syntax, understand **why** this matters for your career transition:

### In Biomedical Discovery:
```python
# Without OOP - messy and error-prone
protein_name = "P53"
protein_sequence = "MEEPQSD..."
protein_structure = [...]
protein_function = "tumor suppressor"

# With OOP - organized and scalable
class Protein:
    def __init__(self, name, sequence):
        self.name = name
        self.sequence = sequence
    
    def predict_structure(self):
        # AlphaFold integration
        pass
    
    def analyze_binding_sites(self):
        # Drug discovery analysis
        pass
```

### In Production ML Systems:
- **Model classes**: Every PyTorch/TensorFlow model is a class
- **Data pipelines**: Dataset classes manage biomedical data
- **Agent systems**: LLM agents use OOP for state management
- **API endpoints**: FastAPI uses OOP for service architecture

---

## 🎓 Intuitive Overview: The Mental Model

### The Evolution of Programming Paradigms

Think of programming evolution like medical diagnosis methods:

1. **Procedural Programming** (Old way)
   - Like following a strict protocol step-by-step
   - Linear: "Do step 1, then step 2, then step 3"
   - Example: Sequential blood test analysis script

```python
# Procedural approach
a = 10
b = 20
sum_result = a + b
print(sum_result)
difference = a - b
print(difference)
```

2. **Functional Programming** (Better)
   - Like creating reusable diagnostic tools
   - Functions reduce redundancy, increase reusability

```python
# Functional approach
def calculate_sum(a, b):
    return a + b

def calculate_difference(a, b):
    return a - b
```

3. **Object-Oriented Programming** (Best for complex systems)
   - Like modeling entire biological systems
   - Bundle data + functions that operate on that data
   - Maps naturally to real-world entities

---

## 🧬 Deep Dive: Classes and Objects

### Core Concept: Blueprint vs. Instance

**Analogy**: Think of DNA vs. actual organisms
- **Class** = DNA blueprint (defines what a human should have)
- **Object** = Actual human (specific instance with unique traits)

```python
# Class: The blueprint
class Student:
    college_name = "ABC College"  # Class attribute (shared)
    
    def __init__(self, name, marks):
        self.name = name      # Instance attribute (unique)
        self.marks = marks    # Instance attribute (unique)

# Objects: Specific instances
student1 = Student("Tony", 97)
student2 = Student("Bruce", 88)
```

### Visual Representation

```
┌─────────────────────────────────────┐
│         CLASS: Student              │
│  (Blueprint/Template)               │
│                                     │
│  Shared Data (Class Attributes):   │
│    - college_name = "ABC College"  │
│                                     │
│  Unique Data (Instance Attrs):     │
│    - name (different per student)  │
│    - marks (different per student) │
│                                     │
│  Behaviors (Methods):              │
│    - welcome()                     │
│    - get_average()                 │
└─────────────────────────────────────┘
           │
           ├──────────────┬──────────────┐
           ▼              ▼              ▼
    ┌──────────┐   ┌──────────┐   ┌──────────┐
    │ Object 1 │   │ Object 2 │   │ Object 3 │
    │ name:    │   │ name:    │   │ name:    │
    │ "Tony"   │   │ "Bruce"  │   │ "Peter"  │
    │ marks: 97│   │ marks: 88│   │ marks: 92│
    └──────────┘   └──────────┘   └──────────┘
```

---

## 🔧 Constructors: The `__init__` Method

### What is a Constructor?

**Intuition**: Like a cell initialization protocol - when a new cell is created, it needs to set up its initial state.

**Key Points**:
- Automatically called when creating a new object
- Used to initialize object attributes
- ALWAYS takes `self` as first parameter

### The `self` Parameter Explained

**The Mystery of `self`**:
```python
class Protein:
    def __init__(self, sequence):
        self.sequence = sequence  # self refers to THIS object
```

**What is `self`?**
- A reference to the current instance
- Like saying "MY sequence" vs. "THAT protein's sequence"
- Not a keyword (you could use another name, but DON'T)
- Convention: ALWAYS use `self`

**Visual Understanding**:
```
When you create: protein1 = Protein("ATCG...")
                          ↓
                  self → protein1
                          │
                  protein1.sequence = "ATCG..."
```

### Constructor Types

```python
# 1. Default Constructor (no parameters except self)
class Cell:
    def __init__(self):
        print("Cell created")

# 2. Parameterized Constructor (takes additional parameters)
class Cell:
    def __init__(self, cell_type, count):
        self.cell_type = cell_type
        self.count = count

# Usage
cell = Cell("T-cell", 1000)
```

---

## 📊 Attributes: Class vs. Instance

### The Critical Distinction

**Instance Attributes**: Unique to each object
- Defined with `self.attribute_name`
- Different for every instance
- Stored separately in memory for each object

**Class Attributes**: Shared across all objects
- Defined directly in class (not in `__init__`)
- Same for every instance
- Stored once in memory

### Biomedical Example

```python
class ClinicalTrial:
    # Class attribute (shared by all trials)
    regulatory_body = "FDA"
    
    def __init__(self, trial_id, patient_count):
        # Instance attributes (unique per trial)
        self.trial_id = trial_id
        self.patient_count = patient_count

# All trials share the same regulatory body
trial1 = ClinicalTrial("NCT001", 100)
trial2 = ClinicalTrial("NCT002", 150)

print(trial1.regulatory_body)  # "FDA"
print(trial2.regulatory_body)  # "FDA" (same for both)
print(trial1.patient_count)    # 100 (unique)
print(trial2.patient_count)    # 150 (unique)
```

### Memory Efficiency

```
Memory Layout:
┌─────────────────────────────┐
│  CLASS LEVEL (1 copy)       │
│  regulatory_body = "FDA"    │ ← Stored once
└─────────────────────────────┘

┌─────────────────────────────┐
│  INSTANCE 1                 │
│  trial_id = "NCT001"        │ ← Stored separately
│  patient_count = 100        │
└─────────────────────────────┘

┌─────────────────────────────┐
│  INSTANCE 2                 │
│  trial_id = "NCT002"        │ ← Stored separately
│  patient_count = 150        │
└─────────────────────────────┘
```

**Why This Matters**: When working with thousands of protein objects or patient records, this memory optimization is crucial!

---

## 🎬 Methods: Behaviors of Objects

### What Are Methods?

**Methods** = Functions that belong to a class
- Operate on object data
- Always take `self` as first parameter (for instance methods)
- Define what objects can DO

### Types of Methods

#### 1. Instance Methods (Most Common)

```python
class Patient:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # Instance method - works with instance data
    def get_info(self):
        return f"Patient: {self.name}, Age: {self.age}"
    
    def is_high_risk(self):
        return self.age > 65

# Usage
patient = Patient("John", 70)
print(patient.get_info())        # "Patient: John, Age: 70"
print(patient.is_high_risk())    # True
```

**Key Point**: `self` gives access to instance attributes

#### 2. Static Methods (No `self` needed)

```python
class Converter:
    @staticmethod
    def celsius_to_fahrenheit(celsius):
        return (celsius * 9/5) + 32
    
    @staticmethod
    def kg_to_lbs(kg):
        return kg * 2.20462

# Usage - no object needed!
temp_f = Converter.celsius_to_fahrenheit(37)  # Body temp
weight_lbs = Converter.kg_to_lbs(70)
```

**When to Use Static Methods**:
- Function doesn't need access to instance data
- Utility functions related to the class
- Mathematical conversions, validations

### Method Flow Diagram

```
Object Creation → Constructor Called → Attributes Set
                                            ↓
                                    Methods Can Access
                                    These Attributes
                                            ↓
                              self.attribute_name in methods
```

---

## 🏗️ The Four Pillars of OOP

### 1. Abstraction: Hiding Complexity

**Intuition**: Like using a medical imaging machine
- You press buttons (simple interface)
- Complex physics happens inside (hidden details)
- You see the scan (essential output)

```python
class MRIScanner:
    def __init__(self):
        self.magnetic_field = False
        self.rf_pulse = False
    
    def start_scan(self):
        # Hide complex implementation
        self._activate_magnetic_field()
        self._send_rf_pulses()
        self._collect_signals()
        print("Scan completed")
    
    def _activate_magnetic_field(self):  # Hidden detail
        self.magnetic_field = True
    
    def _send_rf_pulses(self):  # Hidden detail
        self.rf_pulse = True
    
    def _collect_signals(self):  # Hidden detail
        pass

# User only needs to know:
scanner = MRIScanner()
scanner.start_scan()  # Simple interface!
# They don't need to know about magnetic fields, RF pulses, etc.
```

**Key Principle**: Show only what's necessary, hide implementation details

### 2. Encapsulation: Bundling Data + Methods

**Intuition**: Like a cell membrane
- Keeps everything related together
- Data (attributes) + functions (methods) in one unit
- Controlled access to internal state

```python
class BankAccount:
    def __init__(self, balance, account_number):
        self.balance = balance              # Data
        self.account_number = account_number
    
    def debit(self, amount):                # Method operating on data
        self.balance -= amount
        print(f"₹{amount} debited")
    
    def credit(self, amount):               # Method operating on data
        self.balance += amount
        print(f"₹{amount} credited")
    
    def get_balance(self):                  # Method accessing data
        return self.balance

# Everything about an account is in ONE place
account = BankAccount(10000, "12345")
account.debit(1000)
account.credit(500)
print(account.get_balance())  # 9500
```

**The Capsule Concept**:
```
┌─────────────────────────────────┐
│  ENCAPSULATED UNIT (Object)     │
│                                 │
│  DATA (Attributes):             │
│    - balance = 10000            │
│    - account_number = "12345"   │
│                                 │
│  BEHAVIORS (Methods):           │
│    - debit()                    │
│    - credit()                   │
│    - get_balance()              │
└─────────────────────────────────┘
```

---

## 🧪 Biomedical AI Applications

### 1. Protein Structure Modeling

```python
class Protein:
    def __init__(self, name, sequence):
        self.name = name
        self.sequence = sequence
        self.structure = None
    
    def predict_structure(self):
        """Uses AlphaFold-like model"""
        # Abstraction: Hide complex ML inference
        self.structure = self._run_alphafold()
        return self.structure
    
    def _run_alphafold(self):
        # Hidden implementation
        pass
    
    def calculate_binding_affinity(self, ligand):
        """Drug discovery application"""
        pass

# Usage in drug discovery pipeline
protein = Protein("P53", "MEEPQSD...")
structure = protein.predict_structure()
```

### 2. Medical Imaging Dataset

```python
class MedicalImageDataset:
    """PyTorch-style dataset for X-rays/CT scans"""
    
    def __init__(self, image_dir, labels_file):
        self.image_paths = self._load_paths(image_dir)
        self.labels = self._load_labels(labels_file)
    
    def __len__(self):
        return len(self.image_paths)
    
    def __getitem__(self, idx):
        # Load and preprocess image
        image = self._load_image(self.image_paths[idx])
        label = self.labels[idx]
        return image, label
    
    def _load_image(self, path):
        # Abstraction: hide preprocessing
        pass

# Usage in training loop
dataset = MedicalImageDataset("./xrays", "labels.csv")
```

### 3. Clinical Trial Patient

```python
class Patient:
    # Class attribute: shared protocol
    protocol_version = "v2.1"
    
    def __init__(self, patient_id, age, biomarkers):
        self.patient_id = patient_id
        self.age = age
        self.biomarkers = biomarkers  # Dict of test results
        self.adverse_events = []
    
    def is_eligible(self):
        """Check trial eligibility criteria"""
        if self.age < 18 or self.age > 75:
            return False
        if self.biomarkers['creatinine'] > 2.0:
            return False
        return True
    
    def record_adverse_event(self, event):
        """Track safety data"""
        self.adverse_events.append(event)
    
    def get_risk_score(self):
        """Calculate patient risk"""
        score = 0
        if self.age > 65:
            score += 2
        if len(self.adverse_events) > 0:
            score += len(self.adverse_events)
        return score

# Usage
patient = Patient("PT001", 67, {'creatinine': 1.5})
if patient.is_eligible():
    patient.record_adverse_event("mild nausea")
    risk = patient.get_risk_score()
```

### 4. LLM Agent for Literature Mining

```python
class BiomedicalAgent:
    """Agent for mining PubMed literature"""
    
    def __init__(self, model_name, api_key):
        self.model = self._load_model(model_name)
        self.api_key = api_key
        self.conversation_history = []
    
    def query_literature(self, research_question):
        """Abstraction: Hide complex RAG pipeline"""
        # 1. Retrieve relevant papers
        papers = self._search_pubmed(research_question)
        
        # 2. Extract information
        context = self._extract_context(papers)
        
        # 3. Generate answer
        answer = self._generate_response(context, research_question)
        
        # 4. Track history
        self._update_history(research_question, answer)
        
        return answer
    
    def _search_pubmed(self, query):
        # Hidden implementation
        pass

# Usage
agent = BiomedicalAgent("gpt-4", "key")
answer = agent.query_literature("What are biomarkers for Alzheimer's?")
```

---

## 🎯 Practical Patterns & Best Practices

### 1. Naming Conventions

```python
# ✅ GOOD
class ProteinStructure:  # Class names: CamelCase
    def __init__(self):
        self.amino_acid_sequence = ""  # Attributes: snake_case
    
    def predict_folding(self):  # Methods: snake_case
        pass

# ❌ BAD
class protein_structure:  # Don't use snake_case for classes
    def __init__(self):
        self.AminoAcidSequence = ""  # Don't use CamelCase for attributes
```

### 2. When to Use OOP

**✅ Use OOP when:**
- Modeling real-world entities (patients, proteins, trials)
- Building reusable components (dataset classes, model classes)
- Managing complex state (agent systems, game engines)
- Need inheritance and polymorphism (upcoming concepts)

**❌ Don't force OOP when:**
- Simple scripts (data transformation, one-off analysis)
- Pure mathematical functions (use regular functions)
- Very simple use cases (loading a CSV file once)

### 3. Composition Pattern

```python
# Model complex systems by combining objects
class DNASequence:
    def __init__(self, sequence):
        self.sequence = sequence

class Gene:
    def __init__(self, name, dna_sequence):
        self.name = name
        self.dna = DNASequence(dna_sequence)  # Composition!
    
    def transcribe(self):
        # Use the composed DNA object
        return self.dna.sequence.replace('T', 'U')

# Gene "has-a" DNA sequence
gene = Gene("BRCA1", "ATCGTAGC")
```

---

## ⚠️ Beginner Pitfalls to Avoid

### 1. Forgetting `self`

```python
# ❌ WRONG
class Patient:
    def __init__(self, name):
        name = name  # Missing self!
    
    def get_name(self):
        return name  # Missing self!

# ✅ CORRECT
class Patient:
    def __init__(self, name):
        self.name = name
    
    def get_name(self):
        return self.name
```

**Why**: Without `self`, you're creating local variables that disappear after the method ends.

### 2. Calling Methods Without Parentheses

```python
patient = Patient("John")

# ❌ WRONG
info = patient.get_name  # Returns function object, doesn't call it

# ✅ CORRECT
info = patient.get_name()  # Calls the method
```

### 3. Confusing Class and Instance Attributes

```python
class Trial:
    sponsor = "NIH"  # Class attribute
    
    def __init__(self, trial_id):
        self.trial_id = trial_id  # Instance attribute

trial1 = Trial("NCT001")

# ❌ WRONG: Modifying class attribute through instance
trial1.sponsor = "Private"  # This creates a NEW instance attribute!

# ✅ CORRECT: Modify class attribute through class
Trial.sponsor = "Private"  # All instances see this change
```

### 4. Not Using Constructors Properly

```python
# ❌ BAD: Setting attributes outside __init__
class Drug:
    def __init__(self, name):
        self.name = name
    
    def set_properties(self, mol_weight, solubility):
        self.mol_weight = mol_weight
        self.solubility = solubility

# ✅ GOOD: Initialize everything in __init__
class Drug:
    def __init__(self, name, mol_weight, solubility):
        self.name = name
        self.mol_weight = mol_weight
        self.solubility = solubility
```

---

## 💻 Complete Practice Example: Clinical Trial Management

```python
class ClinicalTrial:
    """
    Comprehensive example combining all concepts
    """
    # Class attribute (shared)
    regulatory_standard = "ICH-GCP"
    
    def __init__(self, trial_id, phase, target_enrollment):
        # Instance attributes (unique per trial)
        self.trial_id = trial_id
        self.phase = phase
        self.target_enrollment = target_enrollment
        self.enrolled_patients = []
        self.status = "Planning"
    
    def enroll_patient(self, patient_id, age, biomarkers):
        """Instance method - operates on this trial"""
        patient = {
            'id': patient_id,
            'age': age,
            'biomarkers': biomarkers,
            'enrollment_date': self._get_current_date()
        }
        self.enrolled_patients.append(patient)
        print(f"Patient {patient_id} enrolled in {self.trial_id}")
        
        # Update status if target reached
        if len(self.enrolled_patients) >= self.target_enrollment:
            self.status = "Fully Enrolled"
    
    def calculate_enrollment_rate(self):
        """Instance method - calculates metrics"""
        current = len(self.enrolled_patients)
        target = self.target_enrollment
        return (current / target) * 100
    
    def get_trial_summary(self):
        """Instance method - generates report"""
        rate = self.calculate_enrollment_rate()
        return f"""
        Trial ID: {self.trial_id}
        Phase: {self.phase}
        Status: {self.status}
        Enrollment: {len(self.enrolled_patients)}/{self.target_enrollment}
        Rate: {rate:.1f}%
        Standard: {self.regulatory_standard}
        """
    
    @staticmethod
    def calculate_sample_size(effect_size, power=0.8, alpha=0.05):
        """Static method - utility function"""
        # Simplified sample size calculation
        z_alpha = 1.96
        z_beta = 0.84
        n = ((z_alpha + z_beta) ** 2) / (effect_size ** 2)
        return int(n * 2)  # Two groups
    
    def _get_current_date(self):
        """Private method - implementation detail"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d")

# Usage demonstration
# 1. Calculate required sample size
required_n = ClinicalTrial.calculate_sample_size(effect_size=0.5)
print(f"Required sample size: {required_n}")

# 2. Create trial
trial = ClinicalTrial(
    trial_id="NCT001234",
    phase="Phase III",
    target_enrollment=required_n
)

# 3. Enroll patients
trial.enroll_patient("PT001", 45, {'creatinine': 1.2, 'glucose': 95})
trial.enroll_patient("PT002", 52, {'creatinine': 1.0, 'glucose': 88})
trial.enroll_patient("PT003", 38, {'creatinine': 1.5, 'glucose': 102})

# 4. Generate report
print(trial.get_trial_summary())
```

**Output**:
```
Required sample size: 64
Patient PT001 enrolled in NCT001234
Patient PT002 enrolled in NCT001234
Patient PT003 enrolled in NCT001234

Trial ID: NCT001234
Phase: Phase III
Status: Planning
Enrollment: 3/64
Rate: 4.7%
Standard: ICH-GCP
```

---

## 🎓 What You Just Learned

### Core Concepts Mastered:
1. ✅ **Classes** - Blueprints for creating objects
2. ✅ **Objects** - Specific instances with unique data
3. ✅ **Constructors** - `__init__` method for initialization
4. ✅ **`self` parameter** - Reference to current instance
5. ✅ **Attributes** - Data (instance vs. class)
6. ✅ **Methods** - Behaviors (instance vs. static)
7. ✅ **Abstraction** - Hiding complexity
8. ✅ **Encapsulation** - Bundling data + methods

### Still to Come (Part 2):
- ⏳ **Inheritance** - Creating class hierarchies
- ⏳ **Polymorphism** - Same interface, different behavior
- ⏳ **Private attributes** - `_` and `__` conventions
- ⏳ **Special methods** - `__str__`, `__repr__`, etc.
- ⏳ **Property decorators** - `@property` for getters/setters

---

## 📚 Next Steps & Resources

### Immediate Practice:
1. **Rewrite one of your existing scripts using classes**
   - Start with something simple (data processing pipeline)
   - Identify entities that could be objects
   
2. **Build a small biomedical project**:
   - Patient record system
   - Protein database manager
   - Simple drug-target interaction tracker

### Deep Dive Resources:

**For Python OOP**:
- "Python Object-Oriented Programming" by Steven F. Lott
- Real Python's OOP tutorials: [realpython.com/python3-object-oriented-programming/](https://realpython.com/python3-object-oriented-programming/)

**For ML/AI Context**:
- PyTorch documentation (see how `nn.Module` uses OOP)
- Hugging Face source code (excellent OOP examples)
- "Hands-On Machine Learning" by Aurélien Géron (Chapter 10)

**Biomedical Specific**:
- BioPython library source code
- "Python for Bioinformatics" by Sebastian Bassi

### Interview Preparation:
Be ready to explain:
- Difference between class and instance attributes
- When to use static methods
- The four pillars of OOP (definition + example)
- Real-world analogy for encapsulation
- How OOP improves code in production systems

---

## 🚀 Connection to Your Goal: Biomedical Generative AI

**How OOP applies to your transition**:

1. **Building LLM Applications**:
   - Agent classes manage state
   - Tool classes encapsulate functionality
   - Memory classes handle conversation history

2. **Fine-tuning Pipelines**:
   - Dataset classes organize biomedical data
   - Trainer classes manage training loops
   - Model classes inherit from base architectures

3. **Production Systems**:
   - Service classes handle API endpoints
   - Cache classes optimize performance
   - Logger classes track experiments

**Example: LLM Agent Architecture** (Preview):
```python
class BiomedicaAgent:
    def __init__(self, model, tools):
        self.model = model  # Encapsulation
        self.tools = tools
        self.memory = ConversationMemory()  # Composition
    
    def query(self, question):
        # Abstraction: hide complex reasoning
        context = self.memory.get_context()
        response = self._reason_and_act(question, context)
        self.memory.add(question, response)
        return response
```

Understanding OOP is **non-negotiable** for building production-grade biomedical AI systems. You're now ready to read and write professional Python code!

---

**Next lesson**: Inheritance and Polymorphism - Building class hierarchies for reusable AI components 🧬
