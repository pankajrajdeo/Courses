# Object-Oriented Programming in Python - Part 2
## Inheritance & Polymorphism for Biomedical AI Engineers

---

## 🎯 Key Takeaways

1. **Inheritance** enables code reuse and hierarchical relationships (like protein families or drug classes)
2. **Polymorphism** allows same operations to work differently on different data types (critical for multi-modal biomedical data)
3. **Private attributes** protect sensitive data (essential for HIPAA compliance in medical applications)
4. **Class methods** vs **instance methods** vs **static methods** - choose the right tool for your design
5. **Operator overloading** enables intuitive syntax for custom scientific objects (vectors, molecules, sequences)

---

## 📋 Prerequisites Check

**You should understand:**
- Basic Python syntax (variables, functions, loops)
- Classes and objects (from Part 1)
- Constructors (`__init__` method)
- Basic OOP concepts (encapsulation, abstraction)

**New concepts introduced:**
- Inheritance hierarchies
- Method overriding
- Polymorphism patterns
- Dunder (magic) methods
- Property decorators

---

## 🧠 Intuitive Overview

Think of OOP as organizing biological knowledge:

- **Classes** = Species/Family classifications
- **Inheritance** = Evolutionary relationships (mammals inherit traits from vertebrates)
- **Polymorphism** = Same function name, different behaviors (like "bind()" works differently for antibodies vs. small molecules)
- **Private attributes** = Protected genetic information that shouldn't be modified directly

**Why this matters for biomedical AI:**
- Medical data has hierarchical relationships (Patient → ICU Patient → Cardiac ICU Patient)
- Molecular data has inheritance patterns (Protein → Enzyme → Kinase)
- Multi-modal systems need polymorphic operations (process text, images, genomic sequences differently)

---

## 1. The `del` Keyword: Memory Management

### What It Does
Deletes object properties or entire objects from memory.

### Why It Matters
In biomedical ML, you'll work with large datasets (medical images, genomic data). Proper memory management prevents crashes.

```python
class Student:
    def __init__(self, name):
        self.name = name

s1 = Student("Shraddha")
print(s1.name)  # Output: Shraddha

# Delete a property
del s1.name
# print(s1.name)  # Error: 'Student' object has no attribute 'name'

# Delete entire object
del s1
# print(s1)  # Error: name 's1' is not defined
```

**Biomedical AI Application:**
```python
class MedicalImage:
    def __init__(self, pixel_data, metadata):
        self.pixel_data = pixel_data  # Large array
        self.metadata = metadata
    
    def process(self):
        # Process image...
        pass
    
    def cleanup(self):
        # Free memory after processing
        del self.pixel_data
        print("Memory freed - keeping only metadata")
```

---

## 2. Private Attributes: Data Protection

### The Concept
In biomedical systems, some data must be protected (patient info, model parameters). Python uses double underscore `__` prefix for private attributes.

### Real-World Analogy
Like a hospital's patient records - accessible inside the hospital system but not from outside.

```python
class Account:
    def __init__(self, account_num, account_pwd):
        self.account_num = account_num      # Public
        self.__account_pwd = account_pwd    # Private (double underscore)
    
    def reset_password(self):
        # Internal method CAN access private attributes
        print(self.__account_pwd)

acc1 = Account("12345", "abcde")

print(acc1.account_num)      # ✅ Works: 12345
# print(acc1.__account_pwd)  # ❌ Error: no attribute '__account_pwd'

acc1.reset_password()        # ✅ Works: abcde (accessed internally)
```

### How It Works
```python
class Person:
    __name = "Anonymous"  # Private class attribute
    
    def __hello(self):    # Private method
        print("Hello person")
    
    def welcome(self):    # Public method
        self.__hello()    # Can call private method internally

p1 = Person()
# p1.__hello()   # ❌ Error: no attribute '__hello'
p1.welcome()     # ✅ Works: calls __hello() internally
```

**Key Insight:** Private attributes/methods are accessible ONLY within the class, not from outside.

### Biomedical AI Application

```python
class PatientRecord:
    def __init__(self, patient_id, diagnosis):
        self.patient_id = patient_id          # Public: non-sensitive ID
        self.__diagnosis = diagnosis          # Private: HIPAA protected
        self.__genetic_data = None            # Private: highly sensitive
    
    def get_anonymized_data(self):
        """Public method for research - returns de-identified data"""
        return {
            "id": self.patient_id,
            "has_condition": self.__diagnosis is not None
            # No direct genetic data exposure
        }
    
    def __decrypt_genetic_data(self):
        """Private method - only accessible internally"""
        # Decryption logic here
        pass

# Usage
patient = PatientRecord("PT001", "Type 2 Diabetes")
research_data = patient.get_anonymized_data()  # ✅ Safe for research
# patient.__diagnosis  # ❌ Error: protected health information
```

**Important Note:** Python's privacy is "by convention" - it uses name mangling (`_ClassName__attribute`). It's not true enforcement like in Java/C++, but it signals intent and prevents accidental access.

---

## 3. Inheritance: The Foundation of Code Reuse

### The Four Pillars of OOP (Recap)
1. ✅ **Abstraction** (Part 1)
2. ✅ **Encapsulation** (Part 1)
3. **Inheritance** ← Today's focus
4. **Polymorphism** ← Coming up

### What Is Inheritance?

**Real-life analogy:** Children inherit traits from parents, grandparents from great-grandparents.

**Programming analogy:** When one class derives properties and methods from another class.

### Visual Representation

```
┌─────────────────┐
│      Car        │  ← Parent/Base Class
│  - start()      │
│  - stop()       │
│  - color        │
└─────────────────┘
        ▲
        │ Inherits from
        │
┌─────────────────┐
│   ToyotaCar     │  ← Child/Derived Class
│  - brand        │
│  + inherits all │
│    Car methods  │
└─────────────────┘
```

### Basic Example

```python
class Car:
    @staticmethod
    def start():
        print("Car started")
    
    @staticmethod
    def stop():
        print("Car stopped")

class ToyotaCar(Car):  # Inherits from Car
    def __init__(self, brand):
        self.brand = brand

# Usage
car1 = ToyotaCar("Fortuner")
print(car1.brand)      # Output: Fortuner
car1.start()           # Output: Car started (inherited method!)
```

**Key Point:** `ToyotaCar` doesn't define `start()` or `stop()`, but inherits them from `Car`.

---

## 4. Types of Inheritance

### 4.1 Single-Level Inheritance

One parent → One child

```
Parent Class → Child Class
```

```python
class Car:
    def __init__(self, type):
        self.type = type
    
    @staticmethod
    def start():
        print("Car started")

class ToyotaCar(Car):
    def __init__(self, brand, type):
        self.brand = brand
        super().__init__(type)  # Call parent constructor

car1 = ToyotaCar("Prius", "Electric")
print(car1.type)    # Electric (from parent)
car1.start()        # Car started (from parent)
```

### 4.2 Multi-Level Inheritance

Grandparent → Parent → Child (chain of inheritance)

```
Car → ToyotaCar → Fortuner
```

```python
class Car:
    @staticmethod
    def start():
        print("Car started")
    
    @staticmethod
    def stop():
        print("Car stopped")

class ToyotaCar(Car):
    def __init__(self, brand):
        self.brand = brand

class Fortuner(ToyotaCar):
    def __init__(self, type):
        self.type = type
        super().__init__("Toyota")  # Sets brand in parent

car1 = Fortuner("Diesel")
print(car1.brand)      # Toyota (from ToyotaCar)
print(car1.type)       # Diesel (from Fortuner)
car1.start()           # Car started (from Car - grandparent!)
```

**Fortuner inherits from ToyotaCar, which inherits from Car** → All methods flow down the chain.

### 4.3 Multiple Inheritance

One child inherits from MULTIPLE parents

```
   Parent A    Parent B
        \       /
         \     /
          Child
```

```python
class A:
    varA = "Welcome to class A"

class B:
    varB = "Welcome to class B"

class C(A, B):  # Inherits from BOTH A and B
    varC = "Welcome to class C"

c1 = C()
print(c1.varC)  # Welcome to class C
print(c1.varB)  # Welcome to class B (from parent B)
print(c1.varA)  # Welcome to class A (from parent A)
```

**Biomedical AI Application:**

```python
class ClinicalData:
    def __init__(self):
        self.vitals = []
        self.lab_results = []

class ImagingData:
    def __init__(self):
        self.scans = []
        self.annotations = []

class MultiModalPatient(ClinicalData, ImagingData):
    """Combines clinical + imaging data for comprehensive analysis"""
    def __init__(self, patient_id):
        ClinicalData.__init__(self)
        ImagingData.__init__(self)
        self.patient_id = patient_id
    
    def get_complete_profile(self):
        return {
            'vitals': self.vitals,
            'labs': self.lab_results,
            'scans': self.scans
        }
```

---

## 5. The `super()` Method: Accessing Parent Class

### What It Does
`super()` calls methods from the parent class, especially the constructor.

### Why Use It?
- Avoid code duplication
- Initialize parent class properly
- Access parent methods even if overridden

```python
class Car:
    def __init__(self, type):
        self.type = type
    
    @staticmethod
    def start():
        print("Car started")

class ToyotaCar(Car):
    def __init__(self, brand, type):
        self.brand = brand
        super().__init__(type)  # Calls Car's __init__
        super().start()         # Calls Car's start() method

car1 = ToyotaCar("Prius", "Electric")
# Output: Car started (from super().start())
print(car1.type)  # Electric (set via super().__init__)
```

### Common Pattern

```python
super().__init__(args)  # Initialize parent
super().method_name()   # Call parent method
```

**Biomedical AI Application:**

```python
class BaseModel:
    def __init__(self, model_name):
        self.model_name = model_name
        self.trained = False
    
    def train(self):
        print(f"Training {self.model_name}...")
        self.trained = True

class ProteinStructureModel(BaseModel):
    def __init__(self, architecture):
        super().__init__("AlphaFold-like")
        self.architecture = architecture
    
    def train(self):
        super().train()  # Call parent train first
        print("Fine-tuning on protein sequences...")

model = ProteinStructureModel("Transformer")
model.train()
# Output:
# Training AlphaFold-like...
# Fine-tuning on protein sequences...
```

---

## 6. Class Methods vs Static Methods vs Instance Methods

This is **critically important** for production ML systems.

### The Three Types

```python
class Example:
    class_var = "Shared by all"
    
    def __init__(self, value):
        self.instance_var = value  # Unique per object
    
    # 1. INSTANCE METHOD (default)
    def instance_method(self):
        """Can access both instance and class variables"""
        return f"{self.instance_var} - {self.class_var}"
    
    # 2. CLASS METHOD
    @classmethod
    def class_method(cls, new_class_var):
        """Can access/modify class variables, NOT instance variables"""
        cls.class_var = new_class_var
    
    # 3. STATIC METHOD
    @staticmethod
    def static_method(x, y):
        """Cannot access instance OR class variables"""
        return x + y
```

### When to Use Each?

| Type | First Parameter | Can Access | Use When |
|------|----------------|------------|----------|
| **Instance Method** | `self` | Instance + Class vars | Need object-specific data |
| **Class Method** | `cls` | Class vars only | Modify class state, factory methods |
| **Static Method** | None | Neither | Utility functions, no state needed |

### Detailed Example

```python
class Person:
    name = "Anonymous"  # Class attribute
    
    def __init__(self):
        pass
    
    # ❌ WRONG: Can't modify class attribute directly
    def change_name_wrong(self, name):
        self.name = name  # Creates NEW instance attribute, doesn't change class attribute!
    
    # ✅ CORRECT: Use class method
    @classmethod
    def change_name(cls, name):
        cls.name = name  # Modifies class attribute

# Test
p1 = Person()
print(Person.name)  # Anonymous

p1.change_name_wrong("Rahul")
print(Person.name)  # Still Anonymous! (class attribute unchanged)
print(p1.name)      # Rahul (new instance attribute created)

Person.change_name("Rahul")
print(Person.name)  # Rahul (class attribute changed!)
```

### Alternative Ways to Access Class Variables

```python
# Option 1: Use class name directly
def change_name(self, name):
    Person.name = name

# Option 2: Use self.__class__
def change_name(self, name):
    self.__class__.name = name

# Option 3: Use @classmethod (BEST)
@classmethod
def change_name(cls, name):
    cls.name = name
```

### Biomedical AI Application

```python
class ModelRegistry:
    """Tracks all trained models across your organization"""
    _models = {}  # Class variable: shared registry
    
    def __init__(self, model_name, version):
        self.model_name = model_name      # Instance variable
        self.version = version
    
    @classmethod
    def register_model(cls, model_name, model_obj):
        """Class method: modifies shared registry"""
        cls._models[model_name] = model_obj
        print(f"Registered {model_name} to global registry")
    
    @classmethod
    def get_model(cls, model_name):
        """Class method: retrieves from shared registry"""
        return cls._models.get(model_name)
    
    @staticmethod
    def validate_version(version_string):
        """Static method: utility function, no state needed"""
        parts = version_string.split('.')
        return len(parts) == 3 and all(p.isdigit() for p in parts)
    
    def train(self):
        """Instance method: trains THIS specific model"""
        print(f"Training {self.model_name} v{self.version}")

# Usage
ModelRegistry.register_model("drug_discovery_v1", "model_object_here")
print(ModelRegistry.validate_version("1.0.0"))  # True

model1 = ModelRegistry("protein_fold", "2.1.0")
model1.train()
```

---

## 7. Property Decorator: Dynamic Attributes

### The Problem

```python
class Student:
    def __init__(self, phy, chem, math):
        self.phy = phy
        self.chem = chem
        self.math = math
        # ❌ BAD: Percentage is calculated once and stored
        self.percentage = str((phy + chem + math) / 3) + "%"

s1 = Student(98, 97, 99)
print(s1.percentage)  # 98.0%

# Teacher corrects physics marks
s1.phy = 86
print(s1.percentage)  # Still 98.0%! ❌ Not updated!
```

**Problem:** Percentage doesn't update when marks change.

**Bad Solution:** Call a method every time

```python
def calculate_percentage(self):
    return str((self.phy + self.chem + self.math) / 3) + "%"

# Usage
s1.phy = 86
print(s1.calculate_percentage())  # Have to call method every time
```

**Better Solution:** Use `@property` decorator

```python
class Student:
    def __init__(self, phy, chem, math):
        self.phy = phy
        self.chem = chem
        self.math = math
    
    @property  # ✅ Makes method act like an attribute
    def percentage(self):
        return str((self.phy + self.chem + self.math) / 3) + "%"

s1 = Student(98, 97, 99)
print(s1.percentage)  # 98.0% (looks like attribute, is calculated)

s1.phy = 86
print(s1.percentage)  # 94.0% (automatically recalculated!)
```

**Key Insight:** `@property` makes a method look like an attribute, but it's calculated dynamically every time you access it.

### Biomedical AI Application

```python
class ClinicalTrial:
    def __init__(self, enrolled, completed, adverse_events):
        self.enrolled = enrolled
        self.completed = completed
        self.adverse_events = adverse_events
    
    @property
    def completion_rate(self):
        """Dynamically calculated - always up-to-date"""
        if self.enrolled == 0:
            return 0
        return (self.completed / self.enrolled) * 100
    
    @property
    def safety_score(self):
        """Composite metric - recalculated on access"""
        if self.completed == 0:
            return 0
        return max(0, 100 - (self.adverse_events / self.completed) * 100)
    
    @property
    def trial_status(self):
        """Dynamic classification"""
        if self.completion_rate >= 90:
            return "Excellent"
        elif self.completion_rate >= 70:
            return "Good"
        else:
            return "Needs Attention"

trial = ClinicalTrial(enrolled=100, completed=85, adverse_events=5)
print(trial.completion_rate)  # 85.0
print(trial.safety_score)     # 94.11764705882352
print(trial.trial_status)     # Good

# Update data
trial.completed = 92
print(trial.completion_rate)  # 92.0 (auto-updated!)
print(trial.trial_status)     # Excellent (auto-updated!)
```

---

## 8. Polymorphism: Many Forms, One Interface

### The Fourth Pillar

**Poly** = Many  
**Morph** = Forms

**Definition:** When the same operator/method behaves differently based on context.

### Operator Overloading: Built-in Polymorphism

```python
# + operator works differently based on type!

print(1 + 2)           # 3 (addition)
print("Hello" + "World")  # HelloWorld (concatenation)
print([1,2] + [3,4])   # [1, 2, 3, 4] (list merge)
```

**Behind the scenes:** Each class defines what `+` means via dunder methods.

```python
print(type(1))          # <class 'int'>
print(type("Hello"))    # <class 'str'>
print(type([1,2]))      # <class 'list'>
```

Each class (`int`, `str`, `list`) has its own `__add__()` method!

---

## 9. Dunder Methods: Magic Functions

### What Are Dunder Methods?

**Dunder** = **D**ouble **Under**score

Methods like `__init__`, `__add__`, `__str__` that have special meaning in Python.

### Common Dunder Methods

```python
__init__(self)        # Constructor
__add__(self, other)  # Defines '+'
__sub__(self, other)  # Defines '-'
__mul__(self, other)  # Defines '*'
__str__(self)         # Defines str(obj) and print(obj)
__len__(self)         # Defines len(obj)
__eq__(self, other)   # Defines '=='
__lt__(self, other)   # Defines '<'
__gt__(self, other)   # Defines '>'
```

### Example: Complex Numbers

**Math Background (optional):**
- **Real numbers:** 1, 2, 3.5, -7
- **Complex numbers:** a + bi (e.g., 1 + 3i)
  - `a` = real part
  - `i` = imaginary unit (√-1)
  - Used in signal processing, quantum computing

**Addition rule:** (a + bi) + (c + di) = (a+c) + (b+d)i

```python
# Example:
# (1 + 3i) + (2 + 5i) = (1+2) + (3+5)i = 3 + 8i
```

### Implementing Complex Number Class

```python
class Complex:
    def __init__(self, real, img):
        self.real = real
        self.img = img
    
    def show_number(self):
        print(f"{self.real}i + {self.img}j")

num1 = Complex(1, 3)
num1.show_number()  # 1i + 3j

num2 = Complex(4, 6)
num2.show_number()  # 4i + 6j

# ❌ This won't work yet!
# num3 = num1 + num2  # Error: unsupported operand type(s) for +
```

### Adding Operator Overloading

```python
class Complex:
    def __init__(self, real, img):
        self.real = real
        self.img = img
    
    def show_number(self):
        print(f"{self.real}i + {self.img}j")
    
    # ✅ Define what '+' means for Complex numbers
    def __add__(self, other):
        new_real = self.real + other.real
        new_img = self.img + other.img
        return Complex(new_real, new_img)
    
    # ✅ Define what '-' means for Complex numbers
    def __sub__(self, other):
        new_real = self.real - other.real
        new_img = self.img - other.img
        return Complex(new_real, new_img)

# Now it works!
num1 = Complex(1, 3)
num2 = Complex(4, 6)

num3 = num1 + num2  # Calls __add__ internally
num3.show_number()  # 5i + 9j

num4 = num1 - num2  # Calls __sub__ internally
num4.show_number()  # -3i + -3j
```

### How It Works Internally

```python
num1 + num2
# ↓ Python translates to:
num1.__add__(num2)
```

### Complete Dunder Method Reference

[Python Documentation - Section 3.3.8](https://docs.python.org/3/reference/datamodel.html)

Common operators:
- `__add__` (+), `__sub__` (-), `__mul__` (*), `__truediv__` (/)
- `__eq__` (==), `__ne__` (!=), `__lt__` (<), `__gt__` (>)
- `__len__` (len()), `__str__` (str()), `__repr__` (repr())

---

## 10. Biomedical AI Application: Molecular Vectors

```python
class MolecularVector:
    """Represents a molecule as a vector in chemical space"""
    def __init__(self, features):
        self.features = features  # List of numerical features
    
    def __add__(self, other):
        """Average two molecular representations"""
        if len(self.features) != len(other.features):
            raise ValueError("Feature dimensions must match")
        avg_features = [(a + b) / 2 for a, b in zip(self.features, other.features)]
        return MolecularVector(avg_features)
    
    def __sub__(self, other):
        """Compute difference vector (for similarity analysis)"""
        diff = [a - b for a, b in zip(self.features, other.features)]
        return MolecularVector(diff)
    
    def __mul__(self, scalar):
        """Scale molecular features"""
        scaled = [f * scalar for f in self.features]
        return MolecularVector(scaled)
    
    def __str__(self):
        return f"MolecularVector({self.features[:5]}... [{len(self.features)} features])"
    
    def similarity(self, other):
        """Cosine similarity"""
        dot_product = sum(a * b for a, b in zip(self.features, other.features))
        mag1 = sum(f ** 2 for f in self.features) ** 0.5
        mag2 = sum(f ** 2 for f in other.features) ** 0.5
        return dot_product / (mag1 * mag2)

# Usage
aspirin = MolecularVector([0.2, 0.5, 0.1, 0.8, 0.3])
ibuprofen = MolecularVector([0.3, 0.6, 0.15, 0.75, 0.35])

# Polymorphic operations!
average_molecule = aspirin + ibuprofen  # Creates hybrid representation
difference = aspirin - ibuprofen        # Finds structural differences
scaled = aspirin * 2                    # Amplify features

print(f"Similarity: {aspirin.similarity(ibuprofen):.2f}")
```

---

## 11. Practice Problems - Worked Solutions

### Problem 1: Circle Class

```python
class Circle:
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return (22/7) * self.radius ** 2
    
    def perimeter(self):
        return 2 * (22/7) * self.radius

c1 = Circle(21)
print(f"Area: {c1.area()}")          # 1386.0
print(f"Perimeter: {c1.perimeter()}")  # 132.0
```

### Problem 2: Employee Inheritance

```python
class Employee:
    def __init__(self, role, dept, salary):
        self.role = role
        self.dept = dept
        self.salary = salary
    
    def show_details(self):
        print(f"Role: {self.role}")
        print(f"Department: {self.dept}")
        print(f"Salary: {self.salary}")

class Engineer(Employee):
    def __init__(self, name, age):
        self.name = name
        self.age = age
        # All engineers have fixed role, dept, salary
        super().__init__("Engineer", "IT", 75000)

e1 = Engineer("Elon Musk", 40)
e1.show_details()
# Output:
# Role: Engineer
# Department: IT
# Salary: 75000
```

### Problem 3: Order Comparison

```python
class Order:
    def __init__(self, item, price):
        self.item = item
        self.price = price
    
    def __gt__(self, other):
        """Define what '>' means for orders"""
        return self.price > other.price

ord1 = Order("Chips", 20)
ord2 = Order("Tea", 15)

print(ord1 > ord2)  # True (20 > 15)
print(ord2 > ord1)  # False
```

---

## 🧬 Advanced Biomedical AI Pattern: Model Inheritance

```python
from abc import ABC, abstractmethod

class BaseMLModel(ABC):
    """Abstract base class for all ML models"""
    def __init__(self, model_name):
        self.model_name = model_name
        self.trained = False
        self.metrics = {}
    
    @abstractmethod
    def train(self, data):
        pass
    
    @abstractmethod
    def predict(self, input):
        pass
    
    def evaluate(self, test_data):
        predictions = [self.predict(x) for x in test_data]
        return predictions

class SequenceModel(BaseMLModel):
    """Base for sequence-based models (DNA, RNA, protein)"""
    def __init__(self, model_name, seq_length):
        super().__init__(model_name)
        self.seq_length = seq_length
    
    def tokenize(self, sequence):
        """Common tokenization for biological sequences"""
        return list(sequence)

class ProteinFoldingModel(SequenceModel):
    """Specialized for protein structure prediction"""
    def __init__(self, architecture):
        super().__init__("ProteinFolder", seq_length=512)
        self.architecture = architecture
    
    def train(self, data):
        print(f"Training {self.model_name} with {self.architecture}...")
        self.trained = True
    
    def predict(self, sequence):
        if not self.trained:
            raise ValueError("Model must be trained first")
        tokens = self.tokenize(sequence)
        # Prediction logic here
        return {"structure": "3D coordinates", "confidence": 0.95}

class DrugBindingModel(SequenceModel):
    """Predicts drug-protein binding affinity"""
    def __init__(self):
        super().__init__("DrugBinder", seq_length=256)
    
    def train(self, data):
        print(f"Training binding affinity predictor...")
        self.trained = True
    
    def predict(self, drug_protein_pair):
        # Binding prediction logic
        return {"affinity": 8.5, "confidence": 0.89}

# Usage
alphafold = ProteinFoldingModel("Transformer")
alphafold.train(training_data)
result = alphafold.predict("MKFLVNVALVFMVVYISYIYA...")
```

---

## 🎯 Common Pitfalls for Beginners

### Pitfall 1: Forgetting `super()`

```python
# ❌ BAD
class Child(Parent):
    def __init__(self, child_attr):
        self.child_attr = child_attr  # Parent not initialized!

# ✅ GOOD
class Child(Parent):
    def __init__(self, child_attr, parent_attr):
        super().__init__(parent_attr)  # Initialize parent first
        self.child_attr = child_attr
```

### Pitfall 2: Confusing Instance vs Class Attributes

```python
class Model:
    trained = False  # ❌ Class attribute - SHARED by all instances!
    
    def train(self):
        self.trained = True  # ❌ Creates new instance attribute, doesn't modify class attribute

# Better
class Model:
    def __init__(self):
        self.trained = False  # ✅ Instance attribute - unique per object
```

### Pitfall 3: Modifying Mutable Class Attributes

```python
# ❌ DANGEROUS
class Experiment:
    results = []  # Shared list - ALL instances modify the SAME list!
    
    def add_result(self, value):
        self.results.append(value)

exp1 = Experiment()
exp2 = Experiment()
exp1.add_result(10)
print(exp2.results)  # [10] ← Contaminated!

# ✅ CORRECT
class Experiment:
    def __init__(self):
        self.results = []  # Each instance gets its own list
```

### Pitfall 4: Overusing Inheritance (Composition is Often Better)

```python
# ❌ Questionable - "IS-A" relationship unclear
class Model(Database, Logger, Validator):
    pass  # Too many parent classes!

# ✅ Better - Use composition ("HAS-A")
class Model:
    def __init__(self):
        self.db = Database()
        self.logger = Logger()
        self.validator = Validator()
```

### Pitfall 5: Not Defining `__repr__` or `__str__`

```python
# ❌ Hard to debug
class Protein:
    def __init__(self, sequence):
        self.sequence = sequence

p = Protein("MKFLVN")
print(p)  # <__main__.Protein object at 0x7f8b1c3d4e10> ← Not helpful!

# ✅ Easy to debug
class Protein:
    def __init__(self, sequence):
        self.sequence = sequence
    
    def __repr__(self):
        return f"Protein('{self.sequence[:10]}...')"
    
    def __str__(self):
        return f"Protein with {len(self.sequence)} residues"

p = Protein("MKFLVN")
print(p)  # Protein with 6 residues
print(repr(p))  # Protein('MKFLVN...')
```

---

## 🔬 Real-World Biomedical AI Example: Multi-Modal Patient Data

```python
from datetime import datetime
from typing import List, Dict, Any

class ClinicalData:
    """Handles structured clinical records"""
    def __init__(self):
        self.vitals = {}
        self.lab_results = {}
        self.medications = []
    
    def add_vital(self, name, value, timestamp=None):
        if timestamp is None:
            timestamp = datetime.now()
        if name not in self.vitals:
            self.vitals[name] = []
        self.vitals[name].append({'value': value, 'time': timestamp})
    
    def get_latest_vital(self, name):
        if name not in self.vitals or not self.vitals[name]:
            return None
        return self.vitals[name][-1]['value']

class ImagingData:
    """Handles medical imaging (X-rays, MRI, CT)"""
    def __init__(self):
        self.scans = []
        self._embeddings = {}  # Private: model-generated embeddings
    
    def add_scan(self, scan_type, image_path, findings):
        scan = {
            'type': scan_type,
            'path': image_path,
            'findings': findings,
            'timestamp': datetime.now()
        }
        self.scans.append(scan)
    
    def __generate_embedding(self, image_path):
        """Private method: only called internally"""
        # Simulate deep learning embedding generation
        import hashlib
        fake_embedding = [hash(image_path) % 100 / 100.0 for _ in range(512)]
        return fake_embedding
    
    def get_scan_embedding(self, scan_index):
        scan_path = self.scans[scan_index]['path']
        if scan_path not in self._embeddings:
            self._embeddings[scan_path] = self.__generate_embedding(scan_path)
        return self._embeddings[scan_path]

class GenomicData:
    """Handles genetic information"""
    def __init__(self):
        self.__genome_sequence = None  # Private: HIPAA protected
        self.variants = []
    
    def set_genome(self, sequence):
        """Setter with validation"""
        valid_bases = set('ACGT')
        if not all(base in valid_bases for base in sequence.upper()):
            raise ValueError("Invalid genome sequence")
        self.__genome_sequence = sequence.upper()
    
    def get_gc_content(self):
        """Public method using private data"""
        if self.__genome_sequence is None:
            return 0
        gc_count = self.__genome_sequence.count('G') + self.__genome_sequence.count('C')
        return gc_count / len(self.__genome_sequence) * 100

class MultiModalPatient(ClinicalData, ImagingData, GenomicData):
    """
    Comprehensive patient representation combining multiple data modalities.
    Uses multiple inheritance to combine capabilities.
    """
    def __init__(self, patient_id, age, sex):
        # Initialize all parent classes
        ClinicalData.__init__(self)
        ImagingData.__init__(self)
        GenomicData.__init__(self)
        
        # Patient-specific attributes
        self.patient_id = patient_id
        self.age = age
        self.sex = sex
        self.risk_scores = {}
    
    @property
    def data_completeness(self):
        """Dynamic property: calculates how much data we have"""
        score = 0
        if self.vitals:
            score += 33
        if self.scans:
            score += 33
        if self.variants or hasattr(self, '_GenomicData__genome_sequence'):
            score += 34
        return score
    
    def calculate_risk_score(self, condition):
        """
        Integrates multi-modal data for risk prediction.
        This is where AI/ML would integrate in real systems.
        """
        # Example: Simplified cardiovascular risk
        if condition == "cardiovascular":
            risk = 0
            
            # Clinical data contribution
            bp = self.get_latest_vital("blood_pressure")
            if bp and bp > 140:
                risk += 30
            
            # Imaging data contribution
            if any("plaque" in scan.get('findings', '').lower() for scan in self.scans):
                risk += 25
            
            # Genomic data contribution
            if any("APOE4" in var for var in self.variants):
                risk += 20
            
            # Age/sex factors
            if self.age > 60:
                risk += 15
            if self.sex == "M":
                risk += 10
            
            self.risk_scores[condition] = risk
            return risk
        
        return None
    
    def __str__(self):
        return (f"Patient {self.patient_id}: {self.age}y {self.sex} "
                f"[{self.data_completeness}% complete]")
    
    def __repr__(self):
        return f"MultiModalPatient(id='{self.patient_id}', age={self.age}, sex='{self.sex}')"

# Usage Example
patient = MultiModalPatient("PT-001", age=65, sex="M")

# Add clinical data
patient.add_vital("blood_pressure", 145)
patient.add_vital("heart_rate", 78)
patient.medications = ["Aspirin", "Metformin"]

# Add imaging data
patient.add_scan("CT", "/path/to/ct.dcm", "Mild coronary artery plaque")

# Add genomic data
patient.set_genome("ACGTACGTACGT" * 100)
patient.variants = ["APOE4", "BRCA1_benign"]

# Calculate risk
cv_risk = patient.calculate_risk_score("cardiovascular")
print(f"Patient: {patient}")
print(f"Data Completeness: {patient.data_completeness}%")
print(f"Cardiovascular Risk: {cv_risk}%")
print(f"GC Content: {patient.get_gc_content():.2f}%")

# Access imaging embeddings
if patient.scans:
    embedding = patient.get_scan_embedding(0)
    print(f"Scan embedding dim: {len(embedding)}")
```

**Output:**
```
Patient: Patient PT-001: 65y M [100% complete]
Data Completeness: 100%
Cardiovascular Risk: 85%
GC Content: 50.00%
Scan embedding dim: 512
```

---

## 🎓 Advanced Pattern: Abstract Base Classes for Model Registry

```python
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any, Dict, List

class BaseAIModel(ABC):
    """Abstract base class enforcing interface for all AI models"""
    
    # Class variable: shared model registry
    _model_registry: Dict[str, 'BaseAIModel'] = {}
    
    def __init__(self, model_id: str, version: str):
        self.model_id = model_id
        self.version = version
        self.created_at = datetime.now()
        self.trained = False
        self.performance_metrics = {}
    
    @abstractmethod
    def train(self, training_data: Any) -> None:
        """Must be implemented by all child classes"""
        pass
    
    @abstractmethod
    def predict(self, input_data: Any) -> Any:
        """Must be implemented by all child classes"""
        pass
    
    @abstractmethod
    def validate(self, validation_data: Any) -> Dict[str, float]:
        """Must be implemented by all child classes"""
        pass
    
    @classmethod
    def register(cls, model: 'BaseAIModel') -> None:
        """Class method: registers model in global registry"""
        cls._model_registry[model.model_id] = model
        print(f"✓ Registered {model.model_id} v{model.version}")
    
    @classmethod
    def get_model(cls, model_id: str) -> 'BaseAIModel':
        """Class method: retrieves model from registry"""
        return cls._model_registry.get(model_id)
    
    @classmethod
    def list_models(cls) -> List[str]:
        """Class method: lists all registered models"""
        return list(cls._model_registry.keys())
    
    @staticmethod
    def validate_version(version: str) -> bool:
        """Static method: utility function for version validation"""
        parts = version.split('.')
        return len(parts) == 3 and all(p.isdigit() for p in parts)
    
    @property
    def model_age_days(self) -> int:
        """Property: dynamically calculated model age"""
        return (datetime.now() - self.created_at).days
    
    def __str__(self) -> str:
        status = "trained" if self.trained else "untrained"
        return f"{self.model_id} v{self.version} ({status})"
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}('{self.model_id}', '{self.version}')"

class ProteinStructurePredictor(BaseAIModel):
    """Predicts 3D protein structure from sequence"""
    
    def __init__(self, architecture: str = "Transformer"):
        super().__init__("ProteinFolder", "1.0.0")
        self.architecture = architecture
        self.max_sequence_length = 512
    
    def train(self, training_data: List[Dict]) -> None:
        print(f"Training {self.architecture}-based protein folder...")
        print(f"  - Processing {len(training_data)} protein structures")
        # Training logic here
        self.trained = True
        self.performance_metrics = {
            'tm_score': 0.92,
            'rmsd': 1.8,
            'training_time_hours': 48
        }
    
    def predict(self, sequence: str) -> Dict[str, Any]:
        if not self.trained:
            raise ValueError("Model must be trained before prediction")
        if len(sequence) > self.max_sequence_length:
            raise ValueError(f"Sequence too long (max {self.max_sequence_length})")
        
        # Prediction logic here
        return {
            'structure': '3D_coordinates_placeholder',
            'confidence': 0.89,
            'method': self.architecture
        }
    
    def validate(self, validation_data: List[Dict]) -> Dict[str, float]:
        # Validation logic
        return {
            'accuracy': 0.87,
            'tm_score': 0.88,
            'samples_tested': len(validation_data)
        }

class DrugTargetInteractionModel(BaseAIModel):
    """Predicts drug-protein binding affinity"""
    
    def __init__(self):
        super().__init__("DrugBindingPredictor", "2.1.3")
        self.feature_dim = 1024
    
    def train(self, training_data: List[Dict]) -> None:
        print(f"Training drug-target interaction model...")
        print(f"  - {len(training_data)} drug-protein pairs")
        self.trained = True
        self.performance_metrics = {
            'pearson_r': 0.78,
            'rmse': 1.2,
            'training_samples': len(training_data)
        }
    
    def predict(self, drug_smiles: str, protein_sequence: str) -> Dict[str, Any]:
        if not self.trained:
            raise ValueError("Model must be trained first")
        
        # Prediction logic
        return {
            'binding_affinity': 7.5,  # pKd value
            'confidence': 0.82,
            'interaction_type': 'competitive_inhibitor'
        }
    
    def validate(self, validation_data: List[Dict]) -> Dict[str, float]:
        return {
            'pearson_r': 0.76,
            'spearman_rho': 0.79,
            'samples': len(validation_data)
        }
    
    def __add__(self, other: 'DrugTargetInteractionModel') -> 'DrugTargetInteractionModel':
        """
        Operator overloading: ensemble two models.
        Shows polymorphism in action!
        """
        ensemble = DrugTargetInteractionModel()
        ensemble.model_id = f"Ensemble_{self.model_id}_{other.model_id}"
        ensemble.trained = self.trained and other.trained
        print(f"Created ensemble: {ensemble.model_id}")
        return ensemble

# Usage
print("="*60)
print("BIOMEDICAL AI MODEL REGISTRY DEMO")
print("="*60)

# Create and register models
protein_model = ProteinStructurePredictor(architecture="AlphaFold")
BaseAIModel.register(protein_model)

drug_model = DrugTargetInteractionModel()
BaseAIModel.register(drug_model)

# Validate version
print(f"\nVersion valid: {BaseAIModel.validate_version('2.1.3')}")

# Train models
print("\n" + "-"*60)
protein_model.train([{"seq": "MKFL...", "structure": "..."}] * 1000)
drug_model.train([{"drug": "aspirin", "protein": "COX2"}] * 500)

# Make predictions
print("\n" + "-"*60)
structure = protein_model.predict("MKFLVNVALVFMVV")
print(f"Predicted structure confidence: {structure['confidence']}")

binding = drug_model.predict("CC(=O)Oc1ccccc1C(=O)O", "MKFLVNVALV")
print(f"Predicted binding affinity: {binding['binding_affinity']} pKd")

# Demonstrate polymorphism: ensemble models
print("\n" + "-"*60)
drug_model2 = DrugTargetInteractionModel()
drug_model2.model_id = "DrugBindingV2"
ensemble_model = drug_model + drug_model2  # Uses __add__ overloading!

# List all models
print("\n" + "-"*60)
print("Registered Models:")
for model_id in BaseAIModel.list_models():
    model = BaseAIModel.get_model(model_id)
    print(f"  • {model}")
    print(f"    Age: {model.model_age_days} days")
    if model.performance_metrics:
        print(f"    Metrics: {model.performance_metrics}")
```

---

## 📊 Mental Model: OOP Hierarchy for Biomedical AI

```
┌─────────────────────────────────────────────────────┐
│              BaseAIModel (Abstract)                 │
│  - Common interface for all models                  │
│  - Model registry (class variable)                  │
│  - Version validation (static method)               │
└─────────────────────────────────────────────────────┘
                        ▲
                        │ Inherits
            ┌───────────┴───────────┐
            │                       │
┌───────────────────────┐  ┌───────────────────────┐
│  SequenceModel        │  │  ImageModel           │
│  - Tokenization       │  │  - Image preprocessing│
│  - Embedding          │  │  - Augmentation       │
└───────────────────────┘  └───────────────────────┘
         ▲                          ▲
         │                          │
    ┌────┴────┐              ┌─────┴─────┐
    │         │              │           │
┌───────┐ ┌──────────┐  ┌────────┐ ┌──────────┐
│Protein│ │Drug-Target│ │PathologyAI │ RadiologyAI│
│Folder │ │Predictor  │ │            │           │
└───────┘ └──────────┘  └────────┘ └──────────┘
```

---

## 🚀 Production Best Practices

### 1. Use Type Hints

```python
from typing import List, Dict, Optional, Union

class ClinicalModel:
    def predict(self, 
                features: List[float], 
                patient_id: str) -> Dict[str, Union[float, str]]:
        """Type hints make code self-documenting"""
        return {'risk': 0.75, 'patient': patient_id}
```

### 2. Implement Logging

```python
import logging

class ProductionModel(BaseAIModel):
    def __init__(self, model_id: str):
        super().__init__(model_id, "1.0.0")
        self.logger = logging.getLogger(model_id)
    
    def predict(self, input_data):
        self.logger.info(f"Prediction requested for {len(input_data)} samples")
        try:
            result = self._run_inference(input_data)
            self.logger.info("Prediction successful")
            return result
        except Exception as e:
            self.logger.error(f"Prediction failed: {e}")
            raise
```

### 3. Separate Concerns with Composition

```python
class ModelPipeline:
    """Composition over inheritance"""
    def __init__(self):
        self.preprocessor = DataPreprocessor()
        self.model = ProteinFolder()
        self.postprocessor = ResultFormatter()
    
    def run(self, data):
        processed = self.preprocessor.transform(data)
        predictions = self.model.predict(processed)
        return self.postprocessor.format(predictions)
```

---

## 🎯 What You Just Learned

### Core Concepts Mastered
- ✅ **Inheritance**: Code reuse through parent-child relationships
- ✅ **Polymorphism**: Same interface, different behaviors
- ✅ **Encapsulation**: Private attributes with `__` prefix
- ✅ **Method Types**: Instance vs Class vs Static
- ✅ **Properties**: Dynamic attributes with `@property`
- ✅ **Dunder Methods**: Operator overloading and magic methods

### Biomedical AI Applications
- Multi-modal patient data integration
- Model registries and versioning
- Polymorphic data processing pipelines
- Protected health information handling
- Molecular representation and operations

---

## 📚 Summary & Next Steps

### What Makes Good OOP Design?

1. **Single Responsibility**: Each class does one thing well
2. **Open/Closed**: Open for extension, closed for modification
3. **Liskov Substitution**: Child classes should work wherever parent classes work
4. **Interface Segregation**: Many specific interfaces > one general interface
5. **Dependency Inversion**: Depend on abstractions, not concrete implementations

### Your Learning Path Forward

**Immediate Practice:**
1. Implement a simple ML model class hierarchy
2. Create a data pipeline using inheritance
3. Build a patient record system with private attributes
4. Practice operator overloading with scientific objects

**Advanced Topics to Explore:**
- Design patterns (Factory, Strategy, Observer)
- Meta-classes and decorators
- Protocol classes (Python 3.8+)
- Data classes and attrs library
- Pydantic for data validation

**Biomedical AI Specific:**
- Hugging Face Transformers architecture (heavy OOP)
- PyTorch model classes and inheritance
- TensorFlow/Keras functional vs OOP APIs
- BioPython class structures
- RDKit molecular objects

### Resources for Deeper Understanding

**Books:**
- "Design Patterns" by Gang of Four
- "Clean Code" by Robert Martin
- "Fluent Python" by Luciano Ramalho (especially Ch. 11-12)

**Online:**
- [Python Official Docs - Data Model](https://docs.python.org/3/reference/datamodel.html)
- [Real Python - OOP](https://realpython.com/python3-object-oriented-programming/)
- [ArjanCodes YouTube](https://www.youtube.com/c/ArjanCodes) - Modern Python patterns

**Biomedical AI Codebases to Study:**
- AlphaFold (DeepMind) - inheritance patterns
- ESM (Meta) - transformer architecture
- DeepChem - molecular ML framework
- MedMNIST - medical imaging datasets

---

## 🔑 Key Takeaway for Biomedical AI

**OOP isn't just syntax - it's about modeling the real world.**

In biomedical AI, you're modeling:
- **Biological hierarchies** (Molecule → Protein → Enzyme)
- **Clinical workflows** (Patient → Diagnosis → Treatment)
- **Data pipelines** (Raw → Processed → Analyzed)
- **Model systems** (Base → Fine-tuned → Ensembled)

Master OOP, and you'll write:
- ✅ Modular, reusable code
- ✅ Maintainable production systems
- ✅ Scalable ML pipelines
- ✅ Collaborative team projects

**Remember:** Start simple, refactor to patterns. Don't over-engineer early - let complexity emerge from needs.

---

*These notes cover Part 2 of Python OOP. For the complete Python series, refer to the playlist and download supplementary materials from the description.*
